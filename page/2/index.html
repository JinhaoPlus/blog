<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="金浩的［賅］博客写点我想明白的">
<meta property="og:type" content="website">
<meta property="og:title" content="new JinhaoPlus()">
<meta property="og:url" content="http://jinhaoplus.top/page/2/index.html">
<meta property="og:site_name" content="new JinhaoPlus()">
<meta property="og:description" content="金浩的［賅］博客写点我想明白的">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="new JinhaoPlus()">
<meta name="twitter:description" content="金浩的［賅］博客写点我想明白的">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '我'
    }
  };
</script>




  <link rel="canonical" href="http://jinhaoplus.top/page/2/"/>

  <title> new JinhaoPlus() </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">new JinhaoPlus()</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            我
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/17/Java二进制字节码的结构、加载/" itemprop="url">
                  Java二进制字节码的结构、加载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-17T13:30:15+08:00" content="2015-10-17">
              2015-10-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/10/17/Java二进制字节码的结构、加载/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/17/Java二进制字节码的结构、加载/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java虚拟机：Java二进制字节码的结构、加载"><a href="#Java虚拟机：Java二进制字节码的结构、加载" class="headerlink" title="Java虚拟机：Java二进制字节码的结构、加载"></a>Java虚拟机：Java二进制字节码的结构、加载</h1><p>这篇文章的素材来自周志明的《深入理解Java虚拟机》。</p>
<p>作为Java开发人员，一定程度了解JVM虚拟机的的运作方式非常重要，本文就一些简单的虚拟机的相关概念和运作机制展开我自己的学习过程，是这个系列的第二篇。</p>
<p>我们在文件里写入了java的源代码，源代码写就后存入磁盘，磁盘上的源代码经过javac命令的编译形成了二进制字节码形成了class文件，经过一番步骤后java虚拟机将这些二进制字节码按照一定的方式读入内存中的不同区域形成了二进制字节码的活化状态，虚拟机使用字节码指定的命令执行这些指令，其间使用字节码中存储的数据，最终完成了任务。这个过程就是java虚拟机执行java二进制字节码的过程的简单概括。可以如下图所示：</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f8jn75ung4j30m405jmxj.jpg" alt=""></p>
<p>这只是对这个过程的简单介绍，实际上其中的每一步都至关重要而且复杂，正是这些过程最终使得我们编写的java源代码能够运行在虚拟机搭建的环境中。</p>
<h2 id="java源代码转换的结果：编译所得到字节码的结构"><a href="#java源代码转换的结果：编译所得到字节码的结构" class="headerlink" title="java源代码转换的结果：编译所得到字节码的结构"></a>java源代码转换的结果：编译所得到字节码的结构</h2><p>java的二进制字节码是一个紧密连接的二进制数码，这个数码的结构如下，各个结构之间是无缝连接的，也因此首先于这种规则，java的二进制代码才不会产生二义性，即虚拟机在读区这些数码时可以唯一地解析出它所表达的意思。</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVajw1f8jn77u0htj30m80cxaaw.jpg" alt=""></p>
<p>这个庞大的结构主要包含以下几个部分：</p>
<h3 id="1-魔数和版本号"><a href="#1-魔数和版本号" class="headerlink" title="1.魔数和版本号"></a>1.魔数和版本号</h3><p>基本的信息用于确定java二进制字节码的特征和加载可行特征。<br>魔数“CAFEBABE”用以确定这段字节码是java字节码的开始，版本号用于确定不同版本的jdk编译了不同版本的java源代码生成了不同版本的二进制字节码，这个标记的另外的目的用于提示虚拟机高于当前版本的二进制字节码可能由于兼容性不能加载。</p>
<h3 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2.常量池"></a>2.常量池</h3><p>所有和程序相关的常量都将加入这个部分中，这个部分开头的常量数决定了常量池中常量的个数以使得虚拟机能够正确解析出哪些部分是常量池。后面的常量以表的形式呈现，“表”是字节码中一个特殊的复合型的数据结构，不同类型的常量有不同的标记tag以指示虚拟机以不同的方式解析出常量的值。这样最终虚拟机将根据不同类型的常量解析出常量池中的全部常量对应的值或索引。</p>
<p>常量分为字面量和符号引用两种，字面量即一般的基本类型的数据，比如整型、浮点型等，而符号引用则是那些需要进一步通过这个符号的值去寻找它真正引用的对象，比如CONSTANT_Fieldref_info类型的常量就是符号引用，必须通过这个字段名去寻找到它真正引用的字段。<br>如下是常量池中的常量类型，另外以CONSTANT_Utf8_info表为例说明了常量表中的结构：</p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVajw1f8jn7aewj4j30m809d0tu.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f8jnauqydhj30m803fq31.jpg" alt=""></p>
<h3 id="3-访问标志"><a href="#3-访问标志" class="headerlink" title="3.访问标志"></a>3.访问标志</h3><p>关乎类的访问权限的信息将会以位的不同的形式展示在这里。<br>以下是访问标志的不同位，如果有好几个访问标志，那么一般将它们做或运算将几个相关的位都展示出来。</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVajw1f8jn7c72euj30m808emya.jpg" alt=""></p>
<h3 id="4-类索引、父类索引和接口索引"><a href="#4-类索引、父类索引和接口索引" class="headerlink" title="4.类索引、父类索引和接口索引"></a>4.类索引、父类索引和接口索引</h3><p>这些字节码向虚拟机提供了这个类的类名、父类的类名和接口名的索引值，这个索引值最终将可以从常量池中获得其对应的全限定名。</p>
<h3 id="5-字段表集合"><a href="#5-字段表集合" class="headerlink" title="5.字段表集合"></a>5.字段表集合</h3><p>（成员变量的描述）这些字节码向虚拟机提供了这个类中包含的字段的个数和每个字段的信息，每个字段同样是用一个字段表来描述的，这个字段表里说明了这个字段的信息：字段的访问权限、名索引在常量池中找到它的名字、描述符说明了这个字段的类型，可能会附带的属性表则会进一步通过拓展的数据结构展示这个字段的其它属性，比如这个字段可能被赋的初值。<br>以下展示的是字段表的结构：</p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVajw1f8jnbzatxtj30m804xmxf.jpg" alt=""></p>
<h3 id="6-方法表集合"><a href="#6-方法表集合" class="headerlink" title="6.方法表集合"></a>6.方法表集合</h3><p>（成员方法的描述）和字段表类似的，这些字节码向虚拟机提供了这个类中包含的方法的个数和每个方法的信息，，每个方法用一个方法表来描述：方法的访问权限、方法名的索引在常量池中找到这个方法的名字、描述符索引得到了这个方法的特征如返回值类型和参数，可能会附带的属性表则会进一步通过拓展的数据结构展示这个方法的其它属性，比如这个方法索引得到的Code属性存在的话那么说明这个方法的方法体是存在的，则接下去的字节码就是具体的方法体了，这个方法体由Code属性表来描述。Code属性表则是更深入的一个数据结构了（字节码的数据结构就是以这样可拓展的方式一步步建立的，当简单的索引或字面量不足以描述的时候就会引入表，以结构化的方式来对所要描述的对象做进一步的阐释），在Code属性表里规定了“Code”常量索引以确定这段字节码是方法体、Code属性长度、最大栈、局部变量空间、代码长、代码、异常数和异常表，还有可能带有其他可拓展的属性表。</p>
<p>以下是方法表的结构，针对方法表中的Code属性表可以看到它的更深一层的结构，方法表中还有其他的属性表可依据情况以供拓展，比如Exceptions属性表用以描述这个方法所要规定的可抛出异常。</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f8jncxvwmxj30m804rweq.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f8jn7gt4yuj30m808ngm8.jpg" alt=""></p>
<h3 id="7-类其它属性表"><a href="#7-类其它属性表" class="headerlink" title="7.类其它属性表"></a>7.类其它属性表</h3><p>基于同样的拓展思想，整体结构最后也预留了同样的属性表来做拓展，包括源代码所在文件等信息都可以拓展在这个部分里。</p>
<p>这个部分我们可以清楚地看出字节码设计者对于数据结构的可拓展性的追求，通过可拓展的属性表的定义，很多难以描述的结构可以更深一步的描述（这有点像是文件的结构：在一个文件难以描述的时候就用一个包含了很多文件的文件夹来共同描述），这种设计最终使java二进制字节码能够长期稳定的存在下来，因为新添加的特性只需要在特定的节点做一个拓展即可。</p>
<blockquote>
<p>上面的部分除了辛苦地使用十六进制编辑器对class文件作分析之外还可以直接使用jdk提供的javap工具进行分析：javap -verbose * ，它将结构化的结果呈现出来：</p>
</blockquote>
<pre><code>jinhaoplus$ javap -verbose MyClass
Classfile /Users/jinhao/Desktop/MyClass.class
  Last modified 2015-10-11; size 288 bytes
  MD5 checksum 8235b2e50d3ca6704b44862387570773
  Compiled from &quot;MyClass.java&quot;
class MyClass
  minor version: 0
  major version: 52
  flags: ACC_SUPER
Constant pool:
   #1 = Methodref          #5.#17         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = String             #18            // a
   #3 = Fieldref           #4.#19         // MyClass.x:Ljava/lang/String;
   #4 = Class              #20            // MyClass
   #5 = Class              #21            // java/lang/Object
   #6 = Utf8               x
   #7 = Utf8               Ljava/lang/String;
   #8 = Utf8               ConstantValue
   #9 = Utf8               y
  #10 = Utf8               C
  #11 = Utf8               &lt;init&gt;
  #12 = Utf8               ()V
  #13 = Utf8               Code
  #14 = Utf8               LineNumberTable
  #15 = Utf8               SourceFile
  #16 = Utf8               MyClass.java
  #17 = NameAndType        #11:#12        // &quot;&lt;init&gt;&quot;:()V
  #18 = Utf8               a
  #19 = NameAndType        #6:#7          // x:Ljava/lang/String;
  #20 = Utf8               MyClass
  #21 = Utf8               java/lang/Object
{
  final java.lang.String x;
    descriptor: Ljava/lang/String;
    flags: ACC_FINAL
    ConstantValue: String a

  char y;
    descriptor: C
    flags:

  MyClass();
    descriptor: ()V
    flags:
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: aload_0
         5: ldc           #2                  // String a
         7: putfield      #3                  // Field x:Ljava/lang/String;
        10: return
      LineNumberTable:
        line 1: 0
        line 2: 4
}
SourceFile: &quot;MyClass.java&quot;
</code></pre><h2 id="java字节码转换为活化的内存数据：类加载的过程"><a href="#java字节码转换为活化的内存数据：类加载的过程" class="headerlink" title="java字节码转换为活化的内存数据：类加载的过程"></a>java字节码转换为活化的内存数据：类加载的过程</h2><p>java的字节码经过了编译存在了磁盘上，那么把它从磁盘里请到内存里成为真正活化可用的内存对象是至关重要的，这个过程称之为类加载过程：Class Loading，这个加载过程结束后class文件里的二进制字节码将会成为内存不同区域里的数据，虚拟机就可以按照原则将这些数据代表的指令执行完成任务。</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f8jn7jhb1cj30cw0m8jsa.jpg" alt=""></p>
<p>上图展示的就是这个过程的分步骤。下面是这几步的功能：</p>
<h3 id="加载的任务："><a href="#加载的任务：" class="headerlink" title="加载的任务："></a>加载的任务：</h3><p>加载就是把二进制字节码转为字节流，通过类的全限定名把对应class文件里的二进制字节码转换为虚拟机内存中方法区里规定的数据结构（也就是说最终虚拟机里的结构并不是二进制字节码的那种紧密型）以完成之后的数据向内存中的分配，同时在堆内存中开辟区域以存放类的java.lang.Class对象以使得将来形成的方法区中的数据能有入口访问。</p>
<p>类加载器：加载的时候是根据全限定名去找到对应的二进制字节码，这个过程是由类加载器完成的，虽然是同一个二进制字节码文件，如果类加载器的选择不同，那么出于安全考虑也不能判定加载出的类是完全一致的，因此自定义加载器和系统的应用程序加载器对同一个类的加载结果是不一样的，要判定这两个类是不一样的。为了解决这个问题，类加载器被设计成了多层继承关系，从上向下分别是启动类加载器、拓展类加载器、应用程序加载器、自定义加载器，加载的时候层层向上代理给父加载器，最终将会使得启动类加载器执行最终的加载，以确保所有同名的类能够被同一个类加载器所加载。</p>
<h3 id="验证的任务："><a href="#验证的任务：" class="headerlink" title="验证的任务："></a>验证的任务：</h3><p>毕竟是文件里的字节码，没有办法保证字节码是不被修改的安全代码，即使保证了没被修改也不能保证代码编写者在满足编译成功之外没有犯下低级的语意错误，所以对字节码的验证工作至关重要，可以一定程度上保证字节码的安全性和正确性，虚拟机将从字节流的格式是否正确（是否满足class字节码的格式限制）、元数据语法是否正确（类的元数据信息是否符合java语言的语法要求）、字节码安全性是否保证（是否有跨越内存安全性的错误和隐患出现）、符号引用验证是否能够通过（符号引用是查看那些非类自身的其它类和这些类中的字段和方法是否真的存在，这个过程是解析时会触发的，解析的过程会去查看这些符号引用到的类的情况是否会出错）。</p>
<h3 id="准备的任务："><a href="#准备的任务：" class="headerlink" title="准备的任务："></a>准备的任务：</h3><p>准备是为了在方法区中为即将要分配内存的数据开始开辟在相应位置开辟内存空间，并将相应的字节流注入到这些空间中去，同时为字段赋初值。值得注意的是，除非字段带有ContantValue属性外，一般情况下赋初值的时候都会为字段赋零值。这个过程结束后方法区里就已经建立起来了类的基本数据结构，这其中包括常量池的常量。</p>
<h3 id="解析的任务："><a href="#解析的任务：" class="headerlink" title="解析的任务："></a>解析的任务：</h3><p>准备阶段结束后类变量就都带着初值在方法区中等待了，但是这个时候方法区中的常量池里的常量却只是一些字面量和符号引用，字面量是可以直接使用的，但是符号引用必须转换为直接引用（可以理解为这些引用真正指向的地址）才能使用，否则这些常量的字面量并不能指定活化在内存里的对象：比如常量池中有一个CONSTANT_Class_info类型的符号引用常量，这个类符号引用里存储的仅仅是类的全限定名的索引，找到全限定名之后也没有什么用处，因为没办法确定符合这个全限定名的类在内存中加载的具体地址，因此必须将这个符号引用对应的类的直接引用（地址）找出来，也就是转换为直接引用。</p>
<p>所以解析的任务就是将常量池里的符号引用转换为直接引用，以使得方法区里的类、父类、接口、字段、方法能够通过自身的索引寻找常量池中的引用时直接定位到这些类、父类、接口、字段、方法的准确的内存地址。</p>
<blockquote>
<p>另外需要注意的是，解析不一定非要在准备之后初始化之前进行，因为我们可以看到这个阶段的主要任务是使用阶段才会用到的，如果程序中有动态绑定的需求时这时候是没有办法把符号引用准确转换为直接引用的。所以解析的阶段有时会在初始化之后甚至使用的过程中才会再进行的。这样做的好处就是能够完成相对灵活的动态绑定。</p>
</blockquote>
<h3 id="初始化的任务："><a href="#初始化的任务：" class="headerlink" title="初始化的任务："></a>初始化的任务：</h3><p>初始化的过程实际上就是执行<clinit>类初始化函数的过程，这个函数执行的其实就是字段的赋值语句和静态代码块的执行，这步过后，所有的字段都将被初始化为程序中赋值语句和静态代码块要求的初值，而不是准备阶段的零值。</clinit></p>
<p>以上几个步骤就是类加载的全过程，在这个过程中，class文件中的二进制字节码以二进制字节流的形式先按照方法区特定的数据结构重整并建立java.lang.Class对象于堆中，验证重整后的二进制字节流没有语法、语意和安全性的问题后虚拟机为即将加载的类在方法区中开辟内存空间，字节流注入开辟的方法区的内存空间并将各字段赋零值，常量池中的符号引用转换为有实际意义的直接引用以访问特定的地址，特定的字段被初始化为程序规定的初值，整个类成功加载到方法区中。</p>
<p>虚拟机规范制定了很多限制，这些限制是必须遵守的，不同的厂商对虚拟机的规范有不同的实现，但是面对限制都是一样的遵守。java虚拟机对于类加载的时机没有明确限制，但是对于类加载过程的初始化的时机却有明确的四个“有且仅有要求”：这些条件下必须对类进行初始化，鉴于类初始化位于类加载过程的最后，所以这个规定也可以大致理解为类加载的时机，这些时机称为“主动引用”：</p>
<ol>
<li><p>new新对象、读写静态字段、调用静态方法的时候必须初始化类：读写静态字段时只初始化这个静态字段所在的类，如果是父类的静态字段则只初始化父类而不初始化字类；另外如果是static final修饰的静态字段，那么在编译的时候就会将其写入常量池，这个时候即使读这个静态字段也不会加载类，因为只需要去常量池中取这个值就好。这两个策略的目的其实都是尽可能地减少类加载的开销；</p>
</li>
<li><p>反射调用的时候初始化类；</p>
</li>
<li><p>初始化类的时候如果父类未初始化要初始化父类；</p>
</li>
<li><p>执行主类（执行的main函数所在类）要初始化。</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/10/Java多线程同步与对象控制权/" itemprop="url">
                  Java多线程同步与对象控制权
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-10T15:14:43+08:00" content="2015-10-10">
              2015-10-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/10/10/Java多线程同步与对象控制权/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/Java多线程同步与对象控制权/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java多线程：Java多线程同步与对象控制权"><a href="#Java多线程：Java多线程同步与对象控制权" class="headerlink" title="Java多线程：Java多线程同步与对象控制权"></a>Java多线程：Java多线程同步与对象控制权</h1><h2 id="join-函数"><a href="#join-函数" class="headerlink" title="join()函数"></a><strong>join()函数</strong></h2><p>Join的含义是：将某一线程加入成为另一个线程的流程之一，换言之就是等待另一个线程执行完毕。</p>
<pre><code>public class JoinTest {
        public static void main(String[] args) throws InterruptedException {
              Thread otherThread = new Thread( new Runnable() {
                      public void run() {
                            try {
                                   for ( int i = 1; i &lt;= 5; i++) {
                                         Thread. sleep(1000);
                                         System. out.println(i + &quot;:辅助线程执行..&quot; );
                                  }
                           } catch (InterruptedException e) {
                                  e.printStackTrace();
                           }
                     }
              });
              otherThread.start();

               try {
                     otherThread.join();
              } catch (InterruptedException e) {
                     e.printStackTrace();
              }
               for ( int i = 1; i &lt;= 5; i++) {
                     Thread. sleep(500);
                     System. out.println(i + &quot;: 主线程正在执行...&quot; );
              }
       }
}
</code></pre><h2 id="wait-函数notify-函数"><a href="#wait-函数notify-函数" class="headerlink" title="wait()函数notify()函数"></a><strong>wait()函数notify()函数</strong></h2><pre><code>* 如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。
* 如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。
</code></pre><p>wait方法阻塞本线程，等待其他线程调用notify方法通知自己可以继续执行，也就是说这一对方法应该结合在一起使用，只有当A线程在wait之后出让资源是其他线程有机会前进，另外的B线程notifyA才能使A线程恢复执行。在Java多线程任务里经常会出现多个线程争夺同一个资源，如果任由其争夺可能会造成问题，所以有序的争夺离不开阻塞和唤醒线程，可以先对线程已经争得的资源加锁，这时其他资源将无法争夺这个加锁的资源，在试用完资源后对资源进行解锁，使得其他线程能够重新获得这个资源的争夺权。（其实这个过程类似于进程的信号量加锁解锁）。阐明这个问题的最好例子莫过于生产者消费者的模拟：</p>
<p>在这个过程中，生产产品、消费产品时所需要的容器是争夺的资源，对这个这多资源在访问时需要加解锁：</p>
<ul>
<li>synchronized(container)：对容器加锁以阻塞其他线程同时访问，亦即使得其他线程处于等待状态；</li>
<li>container.wait()：在容器满时阻塞本线程把容器解锁将容器的控制权交出去，本线程处于等待状态；</li>
<li>container.notify()：在容器空时通知正在等待容器控制权的线程恢复运行，亦即解锁容器；</li>
</ul>
<pre><code>public class ThreadTest {
    private List&lt;Object&gt; container = new ArrayList&lt;Object&gt;();

    public static void main(String[] args) {
        PCTest m = new PCTest();
        new Thread(new Consume(m.getContainer()), &quot;消费者1&quot;).start();
        new Thread(new Product(m.getContainer()), &quot;生产者1&quot;).start();
        new Thread(new Consume(m.getContainer()), &quot;消费者2&quot;).start();
        new Thread(new Product(m.getContainer()), &quot;生产者2&quot;).start();
    }

    public List&lt;Object&gt; getContainer() {
        return container;
    }

    public void setContainer(List&lt;Object&gt; container) {
        this.container = container;
    }
}

class Product implements Runnable {
    private List&lt;Object&gt; container = null;

    public Product(List&lt;Object&gt; lst) {
        this.container = lst;
    }

    public void run() {
        while (true) {
            synchronized (container) {
                if (container.size() &gt;= 5) {
                    try {
                        container.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                container.add(new Object());
                System.out
                        .println(Thread.currentThread().getName() + &quot;生产了一个产品&quot;);
                System.out.println(&quot;现在容器中一共有&quot; + container.size() + &quot;个产品&quot;);
                container.notify();

            }
        }
    }
}

class Consume implements Runnable {
    private List&lt;Object&gt; container = null;

    public Consume(List&lt;Object&gt; lst) {
        this.container = lst;
    }

    public void run() {

        while (true) {
            synchronized (container) {
                if (container.size() == 0) {
                    try {
                        container.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                container.remove(0);
                System.out
                        .println(Thread.currentThread().getName() + &quot;消费了一个产品&quot;);
                System.out.println(&quot;现在容器中一共有&quot; + container.size() + &quot;个产品&quot;);
                container.notify();

            }
        }
    }
}
</code></pre><h2 id="线程死锁的问题"><a href="#线程死锁的问题" class="headerlink" title="线程死锁的问题"></a><strong>线程死锁的问题</strong></h2><p>线程和线程如果在运行的过程中保有同样的资源，如果这些资源的占用在某一时刻无法良好分配，那么就有可能出现死锁：</p>
<pre><code>class MyRunnable implements Runnable{
    Object a;
    Object b;
    public MyRunnable(Object a, Object b) {
        this.a = a;
        this.b = b;
    }
    @Override
    public void run() {
        while(true){
            synchronized (a) {
                synchronized (b) {
                    System.out.println(Thread.currentThread().getName()+&quot; is running&quot;);
                }
            }
        }
    }
}
class ThreadTest{
    public static void main(String[] args) {
        Object a = new Object();
        Object b = new Object();
        MyRunnable myRunnable1 = new MyRunnable(a, b);
        MyRunnable myRunnable2 = new MyRunnable(b, a);
        Thread threadA = new Thread(myRunnable1,&quot;t1&quot;);
        Thread threadB = new Thread(myRunnable2,&quot;t2&quot;);
        threadA.start();
        threadB.start();
    }
}
</code></pre><p>在这个例子中两个线程在运行的过程中必须同时保有两个对象，那么当对象A被一个线程锁定而被另一个线程需要，同时对象B被一个线程锁定而被另一个线程需要的时候就会出现死锁。比如t1拿到A和B后锁定它们运行，t2因为没有A和B处于等待状态，t1运行后解锁先解锁B还没有解锁A，t2拿到这个B后锁定B继而需要A，t1解锁A后t2没有拿到A，t1的下一次循环拿到了这个A并锁定A，这个时候t2需要的A被t1锁定，t1需要的B被t2锁定，最终A和B产生死锁。</p>
<blockquote>
<p>附上Java线程的同步原理</p>
</blockquote>
<h2 id="线程同步的基本原理"><a href="#线程同步的基本原理" class="headerlink" title="线程同步的基本原理"></a><strong>线程同步的基本原理</strong></h2><p>java会为每个object对象分配一个monitor，当某个对象的同步方法（synchronized methods ）或同步块被多个线程调用时，该对象的monitor将负责处理这些访问的并发独占要求。<br>当一个线程调用一个对象的同步方法时，JVM会检查该对象的monitor。如果monitor没有被占用，那么这个线程就得到了monitor的占有权，可以继续执行该对象的同步方法；如果monitor被其他线程所占用，那么该线程将被挂起，直到monitor被释放。<br>当线程退出同步方法调用时，该线程会释放monitor，这将允许其他等待的线程获得monitor以使对同步方法的调用执行下去。<br>注意：java对象的monitor机制和传统的临界检查代码区技术不一样。java的一个类一个同步方法并不意味着同时只有一个线程独占执行（不同对象的同步方法可以同时执行），但临界检查代码区技术确会保证同步方法在一个时刻只被一个线程独占执行。<br>java的monitor机制的准确含义是：任何时刻，对一个指定object对象的某同步方法只能由一个线程来调用。<br>java对象的monitor是跟随object实例来使用的，而不是跟随程序代码。两个线程可以同时执行相同的同步方法，比如：一个类的同步方法是xMethod()，有a,b两个对象实例，一个线程执行a.xMethod()，另一个线程执行b.xMethod(). 互不冲突。</p>
<h2 id="wait-、notify-，notifyAll-的使用"><a href="#wait-、notify-，notifyAll-的使用" class="headerlink" title="wait()、notify()，notifyAll()的使用"></a><strong>wait()、notify()，notifyAll()的使用</strong></h2><p>obj.wait()方法使本线程挂起，并释放obj对象的monitor，只有其他线程调用obj对象的notify()或notifyAll()时，才可以被唤醒。<br>obj.notifyAll()方法唤醒所有阻塞在obj对象上的沉睡线程，然后被唤醒的众多线程竞争obj对象的monitor占有权，最终得到的那个线程会继续执行下去，但其他线程继续等待。<br>obj.notify()方法是随机唤醒一个沉睡线程，过程更obj.notifyAll()方法类似。<br>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，<br>如：</p>
<pre><code>synchronized(x){
    x.notify()
    //或者wait()
}
</code></pre><p>以上内容说明了为什么调用wait()，notify()，notifyAll()的线程必须要拥有obj实例对象的monitor占有权。<br>每个对象实例都有一个等待线程队列。这些线程都是等待对该对象的同步方法的调用许可。对一个线程来说，有两种方法可以进入这个等待线程队列。一个是当其他线程执行同步方法时，自身同时也要执行该同步方法；另一个是调用obj.wait()方法。<br>当同步方法执行完毕或者执行wait()时，其他某个线程将获得对象的访问权。当一个线程被放入等待队列时，必须要确保可以通过notify()的调用来解冻该线程，以使其能够继续执行下去。</p>
<h2 id="wait-与sleep-的区别"><a href="#wait-与sleep-的区别" class="headerlink" title="wait()与sleep()的区别"></a><strong>wait()与sleep()的区别</strong></h2><p>sleep()方法是Thread类的静态方法，不涉及到线程间同步概念，仅仅为了让一个线程自身获得一段沉睡时间。sleep可以在任何地方使用。（所以sleep只跟当前线程自己有关）<br>wait()方法是object类的方法，解决的问题是线程间的同步，该过程包含了同步锁的获取和释放，调用wait方法将会将调用者的线程挂起，直到其他线程调用同一个对象的notify()方法才会重新激活调用者。（所以wait适用于多个线程同步协调时才使用的）</p>
<p><em>注意:线程调用notify()之后，只有该线程完全从 synchronized代码里面执行完毕后，monitor才会被释放，被唤醒线程才可以真正得到执行权。</em></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/09/Java自动内存管理和回收机制/" itemprop="url">
                  Java自动内存管理和回收机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-09T13:38:15+08:00" content="2015-10-09">
              2015-10-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/10/09/Java自动内存管理和回收机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/09/Java自动内存管理和回收机制/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java虚拟机：Java自动内存管理和回收机制"><a href="#Java虚拟机：Java自动内存管理和回收机制" class="headerlink" title="Java虚拟机：Java自动内存管理和回收机制"></a>Java虚拟机：Java自动内存管理和回收机制</h1><p>这篇文章的素材来自周志明的《深入理解Java虚拟机》。<br>作为Java开发人员，一定程度了解JVM虚拟机的的运作方式非常重要，本文就一些简单的虚拟机的相关概念和运作机制展开我自己的学习过程。</p>
<h2 id="虚拟机内存分区"><a href="#虚拟机内存分区" class="headerlink" title="虚拟机内存分区"></a>虚拟机内存分区</h2><p>java虚拟机运行在受不同操作系统操纵的物理机上，不同的操作系统使用不同的底层方法来执行不同的操作，这些方法称之为本地方法：Native Method，本地方法一般执行的都是比较底层的操作，比如说IO、线程管理等，java方法则会执行的一般是相对高级的操作，比如说数逻运算，或者是调用底层的本地方法来完成底层任务。</p>
<p>java虚拟机的运行时数据区域将内存分成了不同的部分协调完成java虚拟机的内存数据交互。</p>
<p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f8jnf4hw0nj30m80eymyn.jpg" alt=""></p>
<p>按照数据存储过程的数据结构可以大致分为：</p>
<p><strong>栈区：</strong></p>
<ul>
<li>虚拟机栈：java虚拟机运行的java方法(java字节码方法)构成的栈空间，这个空间在运行时存储这些方法的局部变量表、操作栈、动态链接和方法出口；</li>
<li>本地方法栈：本地方法在运行时存储数据产生的栈区。</li>
</ul>
<p><strong>堆区：</strong></p>
<ul>
<li>java堆：对象的实例存储在这个共享的堆空间里，由于占有最大的和最有实际意义的空间，这个空间的GC过程时虚拟机运行的重点。</li>
<li>方法区：存储虚拟机运行时加载的类信息、常量、静态变量和即时编译的代码，因此可以把这一部分考虑为一个保存相对来说数据较为固定的部分，常量和静态变量在编译时就确定下来进入这部分内存，运行时类信息会直接加载到这部分内存，所以都是相对较早期进入内存的。</li>
<li>运行时常量池：不是所有的常量都是在编译时就确定下来进入内存的，仍然会有运行时才进入内存的常量，这部分常量一般是编译时产生的一些固定信息，比如说翻译出的引用等，直接在类加载的时候把它们存入运行时常量池有助于提高性能。<br>所有的内存区域的数据交互由程序计数器指导虚拟机完成复杂的逻辑步骤。</li>
</ul>
<p><strong>如何找到一个对象的实例：</strong></p>
<pre><code>Object obj ＝ new Object();
</code></pre><p>在这个过程中在虚拟机栈的局部变量表里创建obj引用，在堆内存里创建Object类的一个实例，最后就是把obj引用和这个对象实例关联起来的问题了，另外，我们需要知道的是，不是所有的实例都完整地保存了所有的类的信息，一般共有的或者静态的类的数据将被保存在方法区中，独有的实例数据才会真的被保存在java堆里，因此每个引用必须同时找到关联它的实例数据和类数据。针对这个问题，有两个办法来做： </p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f8jnfbms8ej30m80a43zi.jpg" alt=""></p>
<p>I. 引用存储的只是实例的句柄，句柄在堆的句柄池中，句柄中保存着到堆中真正实例的地址和到方法区中类数据的地址，这样就可以通过这个句柄可以找到这些地址。</p>
<p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f8jnfdalz9j30m80a4wfg.jpg" alt=""></p>
<p>II. 引用存储的就是实例在堆中的地址，而实例中是含有可以定位类数据的地址的，也就是通过找到的实例地址可以再去寻找它对应的类的数据。</p>
<p><strong>两个和内存溢出相关的异常：</strong></p>
<ul>
<li>StackOverflowError：线程申请的栈深度大于虚拟机的规定值；</li>
<li>OutOfMemoryError：线程扩展增加的内存大于虚拟机的要求；</li>
</ul>
<h2 id="内存回收机制"><a href="#内存回收机制" class="headerlink" title="内存回收机制"></a>内存回收机制</h2><p>虚拟机栈、本地方法栈和计数器大都是编译期确定的内存分配，在线程执行完毕后即会清理，内存回收相对比较容易。所以我们提到的内存回收大都是指堆内存的回收。我们通过如下几个问题来说明内存回收机制：</p>
<h3 id="1-什么样的堆内存是可以回收的呢？"><a href="#1-什么样的堆内存是可以回收的呢？" class="headerlink" title="1. 什么样的堆内存是可以回收的呢？"></a>1. 什么样的堆内存是可以回收的呢？</h3><p>什么样的堆内存是可以回收的呢？简而言之就是那些“没用”的内存，那么怎样的内存是“没用”的呢？即那些通过现有的指针（或称“引用”）条件下再也访问不到的内存对象。所以有这样的算法来描述无效的引用：<br><strong>（引用计数算法）</strong>每个对象都有一个被引用计数器，被引用一次计数器加1，引用被置空时减1，最终被引用计数器的值为0 的即是“无用”的内存对象，它占用的内存可以被回收。<br>（这个算法看起来好像没有问题，但是遭遇到循环引用的时候就会出现问题：如果同时将循环引用的双方置空，那么即使被引用计数器不为0也再也访问不到这些对象了，即发生了内存无故占用）。</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVajw1f8jnghc1jxj30hd0i7q4c.jpg" alt=""></p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVajw1f8jngkb8iuj30b406h3yo.jpg" alt=""></p>
<p>这个过程体现了互相循环引用可能带来的问题，对象仍被引用但是已经不能被访问了，所以是这种算法的缺陷。</p>
<p><strong>（根搜索算法）</strong>将由栈内存或方法区引用的对象作为GCRoots去构建引用链，如果能找到这个对象则说明这个对象能够访问其内存不能被回收，反之通过这些引用链找不到这个对象则说明已经是弃用的对象了，其内存是应该被回收的。（上面的互相循环引用的例子就可以解决了，因为这个问题里面虽然其被引用计数器的值不为0，但是已经没有GCRoots能够找到这些内存了，这个问题里的GC Roots是栈内存里的objA和objB，这两个栈内存里的引用被置空，因此引用链里没办法再找到对内存里的对象了。）</p>
<h3 id="2-确定了有哪些内存该被回收后GC机制是直接回收内存吗？"><a href="#2-确定了有哪些内存该被回收后GC机制是直接回收内存吗？" class="headerlink" title="2. 确定了有哪些内存该被回收后GC机制是直接回收内存吗？"></a>2. 确定了有哪些内存该被回收后GC机制是直接回收内存吗？</h3><p>确定了有哪些内存该被回收后GC机制是直接回收内存吗？GC会给这些内存中的某些对象一次机会，就是那些重写过finalize方法的类的对象，GC会执行这个对象重写过的finalize方法，如果在这个方法中对象重新将自己链接给了某个引用使得这块内存区域重新可以被访问，那么GC就不会在这次回收它，但是，这个过程只能执行一次，下一次再被GC遇到的话就不会顾及这个finalize方法而是直接回收了，因此要注意重写的finalize方法只能执行一次。<br>这个是堆内存中对象的回收，在方法区里保存类信息和常量池的内存同样需要回收，这个过程相对来说更缓慢也并没有那么高效，因为一段时间内线程使用的类和常量池都比较稳定，只有当真的确认有类不再使用且不被反射使用的时候才会卸载类，当真的没有常量再被使用的时候才会释放常量池中不用的常量。</p>
<h3 id="3-内存回收策略和算法是怎样的呢？"><a href="#3-内存回收策略和算法是怎样的呢？" class="headerlink" title="3. 内存回收策略和算法是怎样的呢？"></a>3. 内存回收策略和算法是怎样的呢？</h3><p>知道了哪些内存该被回收、回收前的最后确认之后来说内存回收策略，也就是内存回收的时候究竟是依据什么样的算法进行的？<br><strong>（标记-清除算法）</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVajw1f8jnhwu12jj30fy08twfd.jpg" alt=""></p>
<p><strong>（复制算法）</strong></p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f8jnhyhripj30fi08fgmo.jpg" alt=""></p>
<p><strong>（标记-整理算法）</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVajw1f8jni0awekj30h709h0tn.jpg" alt=""></p>
<p>通过这些算法，jvm可以将已不被引用的无效内存回收，标记-清除算法清理得到的内存往往出现碎片，而标记-整理解决了内存碎片却增加了时间消耗，复制算法则会出现内存浪费的问题，结合不同场景使用不同算法进行垃圾回收是十分重要的。</p>
<h3 id="4-主流垃圾回收收集器"><a href="#4-主流垃圾回收收集器" class="headerlink" title="4. 主流垃圾回收收集器"></a>4. 主流垃圾回收收集器</h3><p>了解了内存垃圾回收的算法，我们来看执行垃圾回收的垃圾收集器。根据堆内存对对象的代的划分我们对堆内存有这样划分：</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f8jniwk3qoj30b40amglt.jpg" alt=""></p>
<p>各版本和种类的垃圾回收器各有其用武之地，配合使用它们得到最好的效果十分重要。因为在垃圾内存回收的过程中对每个对象分代处理，所以对不同代的垃圾内存有不同的收集器去回收：创建不久的对象称为新生代，新生代对象的特点即是生死频率高，从生到死的过程很短，所以再回收时有大量的这样的内存存在，所以采用复制算法采用较大的eden:survivor比率将使得内存较完整也较快地回收，同时，老年代的内存存储的是创建很久仍然没有失去引用的对象，这类对象由于长期存在于内存中且未来的生死也常常不确定，所以需要使用速度慢但是更精确地标记-整理算法。下面是真正执行这些回收过程的收集器：<br><strong>新生代收集器：（主要使用复制算法）</strong></p>
<ul>
<li>Serial收集器：单线程+“Stop the World”停顿式收集</li>
<li>ParNew收集器：多线程版本的Serial收集器</li>
<li>Parallel Scavenge收集器：多线程收集器，关注“吞吐量”</li>
</ul>
<p><strong>老年代收集器：（主要使用标记-整理算法）</strong></p>
<ul>
<li>Serial Old收集器：Serial的老年代版本</li>
<li>Parallel Old收集器：Parallel的老年代版本</li>
<li>CMS收集器：并发收集、低停顿，关注短时间停顿</li>
</ul>
<p>G1收集器：高级和领先的新型垃圾收集器</p>
<h3 id="5-内存分配和回收的全过程："><a href="#5-内存分配和回收的全过程：" class="headerlink" title="5. 内存分配和回收的全过程："></a>5. 内存分配和回收的全过程：</h3><p>JVM虚拟机将会依次对每次即将进入堆内存的对象做出安排，一定时间间隔内对于失去引用的无效内存进行回收，当内存出现溢出的时候试图通过垃圾回收自发解决问题保持系统回归平稳。</p>
<ul>
<li><p>申请内存的对象优先被分配到堆内存的Eden区，如果Eden区的空间不足就向survivor区上放，如果仍然放不下就会引发一次发生在新生代的minor GC，在这次GC过程中，如果发现仍然又放不下的对象，就将这些对象放入老年代内存里去（这种现象是对垃圾回收的统计学规律的挑战，因为理论上大多数新生代内存不应该存活到这个时候，所以这个时候就会引发这种叫做分配担保机制的对象向老年代转移），如果存在失去引用的内存，那么就将剩余存活的对象移往survivor区，剩下的Eden区内存全部清理。</p>
</li>
<li><p>大对象直接进入老年区，上面的描述中我们已经可以看到大的对象在一旦出现长时间存活的时候会引发分配担保机制进入老年区，所以不如直接在刚开始创建这个对象的时候就把它放入老年区。</p>
</li>
<li><p>长期存活的对象直接进入老年区：同上面的描述，长期存活的对象的移动会耗费资源，所以在创建这些长期存活的对象时就将它直接放入老年区。</p>
</li>
<li><p>动态对象的年龄判断：虚拟机并不是一直等待所有的对象都到达老年代的标准才将它们放入老年期，因为那样做可能会使新生代的空间一直很紧张引发不必要的GC，所以在当Survivor区里的对象中相同年龄的对象的大小达到Survivor区的一半时就可以将其移入老年区。</p>
</li>
<li><p>空间分配担保：当每次执行minor GC的时候应该对要晋升到老年代的对象进行分析，如果这些马上要到老年区的老年对象的大小超过了老年区的剩余大小，那么执行一次Full GC以尽可能地获得老年区的空间。</p>
</li>
</ul>
<h3 id="6-一个借助VisualVM工具探查JVM内存管理的实例"><a href="#6-一个借助VisualVM工具探查JVM内存管理的实例" class="headerlink" title="6.一个借助VisualVM工具探查JVM内存管理的实例"></a>6.一个借助VisualVM工具探查JVM内存管理的实例</h3><p>这里我们使用一个实例借助VusualVM来查看程序运行过程中的虚拟机内存分配的过程：<br>在这个例子中，各种参数均使用默认值：</p>
<pre><code>public class VMTest {
    private static final int _1MB = 1024*1024;
    public static void main(String[] args) throws InterruptedException {
        Thread.sleep(4000);
        byte[] allocation1;
        for (int i = 0; i &lt; 400; i++) {
            allocation1 = new byte[_1MB];    
            System.out.println(&quot;Create One&quot;+i);
            Thread.sleep(1000);
        }

    }
}
</code></pre><p>这个例子中，主线程每次循环向虚拟机申请内存创建新对象，然后在循环结束的时候将引用链接到新的对象，原来的对象就会处于失去引用的状态，每隔一段时间后JVM的minor GC就会使得这些弃用的对象占据的内存被回收。以下即是这个过程中VisualVM展示的的实时内存各区占据情况：</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f8jnj7dutyj30m80dwact.jpg" alt=""></p>
<p>这个过程中，我们可以清楚地看出内存分配的全过程。新的对象作为新生代对象会被分配到新生区的Eden区中，在一个循环中这些对象都会被分配到Eden区中，因为Eden区默认的超过600M的空间足够容纳这些对象，当一段时间后发生minor GC的时候就会将仍然存活的（也就是仍然有有效引用的）对象移至空的Survivor区，在这里是Survivor0区，失去引用的对象占据的Eden区空间将会被回收；下一次monor GC到来之前仍然会进行这样的空间分配，Eden区中会产生新的对象并有一些对象会失去有效引用，下一次minor GC到来的时候会把Eden区中存活的对象（以及Survivor0中存活的对象）移至空的Survivor区中，这里是Survivor1，并将Eden和Survivor0回收。注意，每次minor GC进行的时候都会将一个Survivor（from Space）置空，并将存活的对象移至空Survivor（to Space）里，如果Survivor（to Space）空间不足，则会引发分配担保机制将这些存活对象移至老年区。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/07/Java字节码指令的执行/" itemprop="url">
                  Java字节码指令的执行
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-07T13:23:53+08:00" content="2015-10-07">
              2015-10-07
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/10/07/Java字节码指令的执行/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/07/Java字节码指令的执行/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java虚拟机-：Java字节码指令的执行"><a href="#Java虚拟机-：Java字节码指令的执行" class="headerlink" title="Java虚拟机 ：Java字节码指令的执行"></a>Java虚拟机 ：Java字节码指令的执行</h1><p>这篇文章的素材来自周志明的《深入理解Java虚拟机》。</p>
<p>作为Java开发人员，一定程度了解JVM虚拟机的的运作方式非常重要，本文就一些简单的虚拟机的相关概念和运作机制展开我自己的学习过程，是这个系列的第三篇。</p>
<h2 id="虚拟机运行活化的内存数据中的指令：程序的执行"><a href="#虚拟机运行活化的内存数据中的指令：程序的执行" class="headerlink" title="虚拟机运行活化的内存数据中的指令：程序的执行"></a>虚拟机运行活化的内存数据中的指令：程序的执行</h2><p>前面我们说明了java源码被编译成为了二进制字节码，二进制字节码转为内存中方法区里存储的活化对象，那么最重要的程序执行就做好了基础：当方法区里的字段和方法按照虚拟机规定的数据结构排好，常量池中的符号引用数据在加载过程中最大限度地转为了直接引用，那么这个时候虚拟机就可以在加载主类后创建新的线程按步执行主类的main函数中的指令了。</p>
<p>java虚拟机执行程序的基础是特定的二进制指令集和运行时栈帧：</p>
<ul>
<li>二进制指令集是java虚拟机规定的一些指令，在编译后二进制字节码的类方法里的字节码就是这种指令，所以只要找到方法区里的类方法就可以依照这套指令集去执行命令。</li>
<li>运行时栈帧是虚拟机执行的物理所在，在这个栈帧结构上，方法的局部变量、操作数栈、动态链接和返回地址依序排列，依照命令动态变换栈帧上的数据，最终完成所有的这个方法上的指令。</li>
</ul>
<p>栈帧的进一步划分：</p>
<ul>
<li>局部变量表：包括方法的参数和方法体内部的局部变量都会存在这个表中。</li>
<li>操作数栈：操作数栈是一个运行中间产生的操作数构成的栈，这个栈的栈顶保存的就是当前活跃的操作数。</li>
<li>动态链接：我们之前提到这个方法中调用的方法和类在常量池中的符号引用转换为的直接引用就保存在这里，只要访问到这些方法和类的时候就会根据动态链接去直接引用所指的地址加载那些方法。</li>
<li>返回地址：程序正常结束恢复上一个栈帧的状态的时候需要知道上一个指令的地址。</li>
</ul>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f8jmzv8ffwj30c50m8wfp.jpg" alt=""></p>
<p>现在我们使用一个综合实例来说明运行的整个过程：</p>
<p>源代码如下，逻辑很简单：<br>    public class TestDemo {<br>        public static int minus(int x){<br>            return -x;<br>        }<br>        public static void main(String[] args) {<br>            int x = 5;<br>            int y = minus(x);<br>        }<br>    }</p>
<p>我们可以分析它的二进制字节码，当然这里我们借助javap工具进行分析：<br>    jinhaoplus$ javap -verbose TestDemo<br>    Classfile /Users/jinhao/Desktop/TestDemo.class<br>      Last modified 2015-10-17; size 342 bytes<br>      MD5 checksum 4f37459aa1b3438b1608de788d43586d<br>      Compiled from “TestDemo.java”<br>    public class TestDemo<br>      minor version: 0<br>      major version: 52<br>      flags: ACC_PUBLIC, ACC_SUPER<br>    Constant pool:</p>
<pre><code>   #1 = Methodref          #4.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Methodref          #3.#16         // TestDemo.minus:(I)I
   #3 = Class              #17            // TestDemo
   #4 = Class              #18            // java/lang/Object
   #5 = Utf8               &lt;init&gt;
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Utf8               LineNumberTable
   #9 = Utf8               minus
  #10 = Utf8               (I)I
  #11 = Utf8               main
  #12 = Utf8               ([Ljava/lang/String;)V
  #13 = Utf8               SourceFile
  #14 = Utf8               TestDemo.java
  #15 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V
  #16 = NameAndType        #9:#10         // minus:(I)I
  #17 = Utf8               TestDemo
  #18 = Utf8               java/lang/Object
{
  public TestDemo();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 1: 0

  public static int minus(int);
    descriptor: (I)I
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=1, args_size=1
         0: iload_0
         1: ineg
         2: ireturn
      LineNumberTable:
        line 3: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=3, args_size=1
         0: iconst_5
         1: istore_1
         2: iload_1
         3: invokestatic  #2                  // Method minus:(I)I
         6: istore_2
         7: return
      LineNumberTable:
        line 6: 0
        line 7: 2
        line 8: 7
}
SourceFile: &quot;TestDemo.java&quot;
</code></pre><p>这个过程是从固化在class文件中的二进制字节码开始，经过加载器对当前类的加载，虚拟机对二进制码的验证、准备和一定的解析，进入内存中的方法区，常量池中的符号引用一定程度上转换为直接引用，使得字节码通过结构化的组织让虚拟机了解类的每一块的构成，创建的线程申请到了虚拟机栈中的空间构造出属于这一线程的栈帧空间，执行主类的main方法：<br>    public static void main(java.lang.String[]);<br>        descriptor: ([Ljava/lang/String;)V<br>        flags: ACC_PUBLIC, ACC_STATIC<br>        Code:<br>          stack=1, locals=3, args_size=1<br>             0: iconst_5<br>             1: istore_1<br>             2: iload_1<br>             3: invokestatic  #2                  // Method minus:(I)I<br>             6: istore_2<br>             7: return<br>          LineNumberTable:<br>            line 6: 0<br>            line 7: 2<br>            line 8: 7<br>    }<br>首先检查main的访问标志、描述符描述的返回类型和参数列表，确定可以访问后进入Code属性表执行命令，读入栈深度建立符合要求的操作数栈，读入局部变量大小建立符合要求的局部变量表，根据参数数向局部变量表中依序加入参数（第一个参数是引用当前对象的this，所以空参数列表的参数数也是1），然后开始根据命令正式执行：<br>    0: iconst_5<br>将整数5压入栈顶<br>    1: istore_1<br>将栈顶整数值存入局部变量表的slot1（slot0是参数this）<br>    2: iload_1<br>将slot1压入栈顶<br>    3: invokestatic  #2   // Method minus:(I)I<br>二进制invokestatic方法用于调用静态方法，参数是根据常量池中已经转换为直接引用的常量，意即minus函数在方法区中的地址，找到这个地址调用函数，向其中加入的参数为栈顶的值<br>    6: istore_2<br>将栈顶整数存入局部变量的slot2<br>    7: return<br>将返回地址中存储的PC地址返到PC，栈帧恢复到调用前</p>
<p>现在我们分析调用minus函数的时候进入minus函数的过程：<br>    public static int minus(int);<br>        descriptor: (I)I<br>        flags: ACC_PUBLIC, ACC_STATIC<br>        Code:<br>          stack=1, locals=1, args_size=1<br>             0: iload_0<br>             1: ineg<br>             2: ireturn<br>          LineNumberTable:<br>            line 3: 0<br>同样的首先检查minus函数的访问标志、描述符描述的返回类型和参数列表，确定可以访问后进入Code属性表执行命令，读入栈深度建立符合要求的操作数栈，读入局部变量大小建立符合要求的局部变量表，根据参数数向局部变量表中依序加入参数，然后开始根据命令正式执行：<br>    0: iload_0<br>将slot0压入栈顶，也就是传入的参数<br>    1: ineg<br>将栈顶的值弹出取负后压回栈顶<br>    2: ireturn<br>将返回地址中存储的PC地址返到PC，栈帧恢复到调用前</p>
<p>这个过程结束后对象的生命周期结束，因此开始执行GC回收内存中的对象，包括堆中的类对应的java.lang.Class对象，卸载方法区中的类。</p>
<h2 id="方法的解析和分派"><a href="#方法的解析和分派" class="headerlink" title="方法的解析和分派"></a>方法的解析和分派</h2><p>上面这个例子中main方法里调用minus方法的时候是没有二义性的，因为从二进制字节码里我们可以看到invokestatic方法调用的是minus方法的直接引用，也就说在编译期这个调用就已经决定了。这个时候我们来说说方法调用，这个部分的内容在前面的类加载时候提过，在能够唯一确定方法的直接引用的时候虚拟机会将常量表里的符号引用转换为直接引用，这样在运行的时候就可以直接根据这个地址找到对应的方法去执行，这种时候的转换才能叫做我们当时提到的在连接过程中的解析。<br>但是如果方法是动态绑定的，也就是说在编译期我们并不知道使用哪个方法（或者叫不知道使用方法的哪个版本），那么这个时候就需要在运行时才能确定哪个版本的方法将被调用，这个时候才能将符号引用转换为直接引用。这个问题提到的多个版本的方法在java中的重载和多态重写问题息息相关。</p>
<p><strong>重载（override）</strong></p>
<pre><code>public class TestDemo {
    static class Human{
    }
    static class Man extends Human{

    }
    static class Woman extends Human{

    }
    public void sayHello(Human human) {
        System.out.println(&quot;hello human&quot;);
    }
    public void sayHello(Man man) {
        System.out.println(&quot;hello man&quot;);
    }
    public void sayHello(Woman woman) {
        System.out.println(&quot;hello woman&quot;);
    }
    public static void main(String[] args) {
        TestDemo demo = new TestDemo();
        Human man = new Man();
        Human woman = new Woman();
        demo.sayHello(man);
        demo.sayHello(woman);
    }
}
</code></pre><p>javap结果：</p>
<pre><code>public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
         0: new           #7                  // class TestDemo
         3: dup
         4: invokespecial #8                  // Method &quot;&lt;init&gt;&quot;:()V
         7: astore_1
         8: new           #9                  // class TestDemo$Man
        11: dup
        12: invokespecial #10                 // Method TestDemo$Man.&quot;&lt;init&gt;&quot;:()V
        15: astore_2
        16: new           #11                 // class TestDemo$Woman
        19: dup
        20: invokespecial #12                 // Method TestDemo$Woman.&quot;&lt;init&gt;&quot;:()V
        23: astore_3
        24: aload_1
        25: aload_2
        26: invokevirtual #13                 // Method sayHello:(LTestDemo$Human;)V
        29: aload_1
        30: aload_3
        31: invokevirtual #13                 // Method sayHello:(LTestDemo$Human;)V
        34: return
      LineNumberTable:
        line 21: 0
        line 22: 8
        line 23: 16
        line 24: 24
        line 25: 29
        line 26: 34
</code></pre><p><strong>重写（overwrite）</strong></p>
<pre><code>public class TestDemo {
    static class Human{
        public void sayHello() {
            System.out.println(&quot;hello human&quot;);
        }
    }
    static class Man extends Human{
        public void sayHello() {
            System.out.println(&quot;hello man&quot;);
        }
    }
    static class Woman extends Human{
        public void sayHello() {
            System.out.println(&quot;hello woman&quot;);
        }
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
    }
}
</code></pre><p>javap结果：</p>
<pre><code>public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: new           #2                  // class TestDemo$Man
         3: dup
         4: invokespecial #3                  // Method TestDemo$Man.&quot;&lt;init&gt;&quot;:()V
         7: astore_1
         8: new           #4                  // class TestDemo$Woman
        11: dup
        12: invokespecial #5                  // Method TestDemo$Woman.&quot;&lt;init&gt;&quot;:()V
        15: astore_2
        16: aload_1
        17: invokevirtual #6                  // Method TestDemo$Human.sayHello:()V
        20: aload_2
        21: invokevirtual #6                  // Method TestDemo$Human.sayHello:()V
        24: return
      LineNumberTable:
        line 20: 0
        line 21: 8
        line 22: 16
        line 23: 20
        line 24: 24
</code></pre><p>我们可以看出来无论是重载还是重写，都是二进制指令invokevirtual调用了sayHello方法来执行的。</p>
<ul>
<li>在重载中，程序调用的是参数实际类型不同的方法，但是虚拟机最终分派了相同外观类型（静态类型）的方法，这说明在重载的过程中虚拟机在运行的时候是只看参数的外观类型（静态类型）的，而这个外观类型（静态类型）是在编译的时候就已经确定的，和虚拟机没有关系。这种依赖静态类型来做方法的分配叫做静态分派。</li>
<li>在重写中，程序调用的是不同实际类型的同名方法，虚拟机依据对象的实际类型去寻找是否有这个方法，如果有就执行，如果没有去父类里找，最终在实际类型里找到了这个方法，所以最终是在运行期动态分派了方法。在编译的时候我们可以看到字节码指示的方法都是一样的符号引用，但是运行期虚拟机能够根据实际类型去确定出真正需要的直接引用。这种依赖实际类型来做方法的分配叫做动态分派。得益于java虚拟机的动态分派会在分派前确定对象的实际类型，面向对象的多态性才能体现出来。</li>
</ul>
<h2 id="对象的创建和堆内存的分配"><a href="#对象的创建和堆内存的分配" class="headerlink" title="对象的创建和堆内存的分配"></a>对象的创建和堆内存的分配</h2><p>前面我们提到的都是类在方法区中的内存分配：</p>
<p>在方法区中有类的常量池，常量池中保存着类的很多信息的符号引用，很多符号引用还转换为了直接引用以使在运行的过程能够访问到这些信息的真实地址。</p>
<p>那么创建出的对象是怎么在堆中分配空间的呢？</p>
<p>首先我们要明确对象中存储的大部分的数据就是它对应的非静态字段和每个字段方法对应的方法区中的地址，因为这些东西每个对象都是不一样的，所以必须通过各自的堆空间存储这些不一样的数据，而方法是所有同类对象共用的，因为方法的命令是一样的，每个对象只是在各自的线程栈帧里提供各自的局部变量表和操作数栈就好。</p>
<p>这样看来，堆中存放的是真正“有个性”的属于对象自己的变量，这些变量往往是最占空间的，而这些变量对应的类字段的地址会找到位于方法区中，同样的同类对象如果要执行一个方法只需要在自己的栈帧里面创建局部变量表和操作数栈，然后根据方法对应的方法区中的地址去寻找到方法体执行其中的命令即可，这样一来堆里面只存放有限的真正有意义的数据和地址，方法区里存放共用的字段和方法体，能最大程度地减小内存开销。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/04/JavaIO不同情境使用的流/" itemprop="url">
                  JavaIO不同情境使用的流
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-04T15:05:08+08:00" content="2015-10-04">
              2015-10-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/10/04/JavaIO不同情境使用的流/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/04/JavaIO不同情境使用的流/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JavaIO-不同情境使用的流"><a href="#JavaIO-不同情境使用的流" class="headerlink" title="JavaIO : 不同情境使用的流"></a>JavaIO : 不同情境使用的流</h1><h2 id="不同情境的流："><a href="#不同情境的流：" class="headerlink" title="不同情境的流："></a>不同情境的流：</h2><p>流的种类很多，针对不同的IO数据交换情景我们可以选择不同的流来完成任务。</p>
<p>我们在前面已经提到的几种流就有它们的使用情境：</p>
<h3 id="1-FileInputStream和FileOutputStream"><a href="#1-FileInputStream和FileOutputStream" class="headerlink" title="1. FileInputStream和FileOutputStream"></a>1. FileInputStream和FileOutputStream</h3><p>FileInputStream和FileOutputStream主要用于解决不限于纯文本的二进制文件的输入输出情境。同时，如果使用带有缓冲区的缓冲输入输出流的话会使得读写IO的效率更高，有助于更快地完成不限于纯文本的二进制文件的读写。</p>
<pre><code>public class FilesTest {
    public static void main(String[] args) throws IOException {
        FileInputStream fileInputStream = new FileInputStream(new File(&quot;1.png&quot;));
        BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
        FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;2.png&quot;));
        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);
        byte[] buffer = new byte[1024];
        while(bufferedInputStream.read(buffer)!=-1){
            bufferedOutputStream.write(buffer);
        }
        bufferedInputStream.close();
        bufferedOutputStream.close();
        fileInputStream.close();
        fileOutputStream.close();
    }
}
</code></pre><h3 id="2-FileReader和FileWriter"><a href="#2-FileReader和FileWriter" class="headerlink" title="2. FileReader和FileWriter"></a>2. FileReader和FileWriter</h3><p>FileReader和FileWriter主要用于解决字符文本文件的读写，因为在这些流提供了很多有利于处理字符的方法来对字符进行丰富的处理。同样的，如果使用带有缓冲区的输入输出流同样可以提高IO读写效率。</p>
<pre><code>public class FilesTest {
public static void main(String[] args) throws IOException {
        FileReader fileReader = new FileReader(new File(&quot;1.txt&quot;));
        FileWriter fileWriter = new FileWriter(new File(&quot;2.txt&quot;));
        BufferedReader bufferedReader = new BufferedReader(fileReader);
        BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
        String haveRead;
        while((haveRead=bufferedReader.readLine())!=null){
        bufferedWriter.write(haveRead);
        }
        bufferedReader.close();
        bufferedWriter.close();
        fileWriter.close();
        fileReader.close();
    }
}
</code></pre><h3 id="3-ByteArrayInputStream和ByteArrayOutputStream"><a href="#3-ByteArrayInputStream和ByteArrayOutputStream" class="headerlink" title="3. ByteArrayInputStream和ByteArrayOutputStream"></a>3. ByteArrayInputStream和ByteArrayOutputStream</h3><p>内存流的输入输出端不是IO文件而是内存中的对象，使用方法和IO流一样，一般使用内存流直接向流中注入数据再传到其他的IO文件中去或者把从IO文件中读取的数据注入到内存对象中去。</p>
<pre><code>//创建与内存对象相关联的流，将内存对象中的数据写入到IO文件中去：

public class FilesTest {
public static void main(String[] args) throws IOException {
String temp = &quot;abcd&quot;;

byte[] buffer = temp.getBytes();

ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(buffer);

FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;test.txt&quot;));

byte[] swap = new byte[1024];

while(byteArrayInputStream.read(swap)!=-1){

fileOutputStream.write(swap);


}

byteArrayInputStream.close();

fileOutputStream.close();

    }
}

//创建与内存对象相关联的流，将IO对象中的数据写入到内存对象中去：

public class FilesTest {
public static void main(String[] args) throws IOException {
byte[] des = new byte[1024];

FileInputStream fileInputStream = new FileInputStream(new File(&quot;test.txt&quot;));

ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();

byte[] buffer = new byte[1024];

while(fileInputStream.read(buffer)!=-1){

byteArrayOutputStream.write(buffer);


}

des = byteArrayOutputStream.toByteArray();

fileInputStream.close();

byteArrayOutputStream.close();

System.out.println(new String(des));

    }
}
</code></pre><h3 id="4-System-in和System-out"><a href="#4-System-in和System-out" class="headerlink" title="4. System.in和System.out"></a>4. System.in和System.out</h3><p>作为非常重要的IO对象，标准输入输出System.in和System.out这一对对象同样可以建立起关联它们的流，这些流把标准输入输出设备中的数据作为源或目标，将这些数据和内存中的程序交互。(可以把标准输入输出想成一般的文件，标准输入就像是一个数据是即时写入的文件，而标准输出就像是一个数据是即时写出的文件)</p>
<pre><code>public class FilesTest {
    public static void main(String[] args) throws IOException {
        byte[] des = new byte[1024];
        DataInputStream dataInputStream = new DataInputStream(System.in);
        dataInputStream.read(des);
        DataOutputStream dataOutputStream = new DataOutputStream(System.out);
        dataOutputStream.write(des);
        dataInputStream.close();
        dataOutputStream.close();
    }
}
</code></pre><h2 id="流的转换"><a href="#流的转换" class="headerlink" title="流的转换"></a>流的转换</h2><p>对于字节流和字符流也可以通过转换的方法来灵活使用，也就是构造字节流和字符流在同一个流对象链上就可以了，相当于字节流在直接和程序交互之前先将数据流到字符流里做一下处理。这个过程也可以使用专有的InputStreamReader和OutputStreamWriter来实现：这个过程将FileInputStream流里的数据按一种编码方式读入InputStreamReader，然后按另一种编码方式从OutputStreamWriter写入到FileOutputStream中这个过程实现了对字符编码的修改，是字符流的特征。</p>
<pre><code>public class FilesTest {
    public static void main(String[] args) throws IOException {
        FileInputStream fileInputStream = new FileInputStream(new File(&quot;1.txt&quot;));
        InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream,&quot;iso8859-1&quot;);
        FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;2.txt&quot;));
        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream,&quot;utf-8&quot;);
        char[] buffer = new char[1024];
        while(inputStreamReader.read(buffer)!=-1){
            outputStreamWriter.write(buffer);
        }
        inputStreamReader.close();
        outputStreamWriter.close();
        fileInputStream.close();
        fileOutputStream.close();
    }
}
</code></pre><p>这个例子是对BufferReader进一步转换的工具类Scanner的使用，在底层使用BufferReader的Scanner可以在缓冲区对数据进行暂存并进一步进行处理，比如按符号划分：</p>
<pre><code>public class FilesTest {
    public static void main(String[] args) {
        try (Scanner scanner = new Scanner(new BufferedReader(new FileReader(&quot;test.txt&quot;)));) {
            scanner.useDelimiter(&quot;[,|^]&quot;);
            while (scanner.hasNext()) {
                System.out.println(scanner.next());
            }
            System.out.println(&quot;Done!&quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/03/JavaIO输入输出流/" itemprop="url">
                  JavaIO输入输出流
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-03T15:11:40+08:00" content="2015-10-03">
              2015-10-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/10/03/JavaIO输入输出流/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/03/JavaIO输入输出流/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JavaIO-：JavaIO输入输出流"><a href="#JavaIO-：JavaIO输入输出流" class="headerlink" title="JavaIO ：JavaIO输入输出流"></a>JavaIO ：JavaIO输入输出流</h1><h1 id="流的原理："><a href="#流的原理：" class="headerlink" title="流的原理："></a>流的原理：</h1><p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f8jq3o8mg8j30fz05bdg9.jpg" alt=""></p>
<p>一连串有顺序的数据系列可以看成是一个流。</p>
<h1 id="输入输出流："><a href="#输入输出流：" class="headerlink" title="输入输出流："></a>输入输出流：</h1><blockquote>
<p>数据从IO输入到程序的流是输入流，数据从程序输出到IO的流是输出流。</p>
</blockquote>
<p>下面我们使用字节输入输出流来说明这个问题：</p>
<ul>
<li><p>输入流 InputStream一般是由javaio对象（如File）建立的，当新建一个InputStream时，io对象建立了一个包含有数据的管道（其实就是我们所说的这个“流”）并将io对象存储的数据输入（input）到管道中，因此管道里的数据流就是io对象内的数据。当调用InputStream数据流的read方法时，管道里的数据流读出到内存对象中（比如数组或者字符串），注意，读出的比特流将会被移除，具体能可读的数据的量可用available函数来查看；</p>
</li>
<li><p>输出流 OutputStream也是由javaio对象（如File）建立的，当新建一个OutputStream时，io对象建立了一个包含有数据流的管道并建立起io对象和管道的映射。 当调用OutputStream数据流的write方法时，内存对象里的数据就会流入管道里，而管道里的数据流输出（output）到io对象中，flush函数将促使数据缓冲区中的数据被写入到io设备（文件本身）中区；</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVajw1f8jq3ufog5j30bx0m8mxf.jpg" alt=""></p>
<pre><code>public class FilesTest {
    public static void main(String[] args) throws IOException {
       File file = new File(“1.txt&quot;);
       InputStream inputStream = new FileInputStream(file);
       byte[] buffer = new byte[1024];
       while(inputStream.read(buffer)!=-1)
        System.out.println(new String(buffer));
       inputStream.close();
    }
}
</code></pre><p>在这个例子里我们可以充分看出输入流创建和输入的过程，首先创建一个File对象来映射IO上的这个文件，依据这个File对象来创建输入流InputStream对象，注意，创建过后输入流里按序存储着IO文件里的数据内容（这个过程中可能InputStream并不是其存储作用的，因为若果这样大文件内的数据一次性存储可能会爆内存，所以这个过程应该是InputStream映射到IO文件），调用输入流InputStream对象的read方法，即可将流内的数据输入到程序中的之前创建的对象内，最终在使用完后关闭作为有限资源的输入流。这个过程完成了数据由IO对象输入到程序。</p>
<p>注意：如果是上次没有读完输入流内的内容，那么下一次程序到InputStream去读的时候是接着上次的结尾读的，这个可以根据InputStream对象的available方法看出来，所以在这个角度来看输入流就像是文件里的索引指针一样。</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f8jq43wsyfj30d40m8t90.jpg" alt=""></p>
<pre><code>public class FilesTest {
    public static void main(String[] args) throws IOException {
       File file = new File(&quot;test.txt&quot;);
       OutputStream outputStream = new FileOutputStream(file);
       byte[] buffer = &quot;hello&quot;.getBytes();
       outputStream.write(buffer);
       outputStream.close();
    }
}
</code></pre><p>在这个例子里我们可以充分看出输出流创建和输出的过程，首先创建一个File对象来映射IO上的这个文件，依据这个File对象来创建输出流OutputStream对象，调用输出流OutputStream对象的write方法，即可将程序对象中的数据写到输出流中然后从输出流输出到IO文件中去，最终在使用完后关闭作为有限资源的输出流。这个过程完成了数据由程序输出到IO文件中。</p>
<p>字符输入输出流的道理是一样的，只不过字符流是直接处理字符的，而字节流的处理单位是字节。<br>read和write的API大同小异，无非就是把流里面的内容和缓冲区通过这些函数来进行交换。</p>
<h1 id="流的流："><a href="#流的流：" class="headerlink" title="流的流："></a>流的流：</h1><p>既然可以依据IO文件来创建流在文件和程序之间交换数据，那么我们可不可以从中间再加入一个流来作为中转处理一下数据呢？这个流的流构成的多流链称之为“流对象链”，这个过程说明不是所有的流都是直接和原始数据源打交道的，所以有如下定义：</p>
<p>节点流（Node Stream）直接连接到数据源，直接从IO文件上输入或输出数据；<br>处理流（Processing Stream）是对一个已存在的流的连接和封装,通过所封装的流的功能调用实现增强的数 据读写功能,它并不直接连到数据源。</p>
<pre><code>public class FilesTest {
    public static void main(String[] args) throws IOException {
        FileOutputStream outputStream = new FileOutputStream(&quot;1.txt&quot;);
        PrintStream printStream = new PrintStream(outputStream);
        printStream.print(&quot;xxx&quot;);
        printStream.close();
        outputStream.close();
    }
}
</code></pre><p>这个过程的原理如下图所示：</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f8jq4i3zy9j30et0m8jrv.jpg" alt=""></p>
<p>在这个例子里我们可以充分看出流对象链形成的过程，首先创建一个File对象来映射IO上的这个文件，依据这个File对象来创建输出流OutputStream对象，利用这个输出流对象再创建一个PrintStream对象来链接输出流对象，调用PrintStream对象的print方法，即可将程序对象中的数据写到PrintStream中然后再输出到IO文件中去，最终在使用完后关闭作为有限资源的流。这个过程完成了数据由程序输出到IO文件中。</p>
<h1 id="流中的缓冲技术"><a href="#流中的缓冲技术" class="headerlink" title="流中的缓冲技术"></a>流中的缓冲技术</h1><p>在内存中开辟一块区域,称为缓冲区，当缓冲区满时一次写入到磁盘中，提高了I/O的性能。和一般的输入输出流相比，这样的带有缓冲区的流可以做到更好的IO性能，在带缓冲的输出流时由于缓冲区的存在，需要在最后强制使用flush函数将缓冲区中剩余的内容全部输出到IO设备中去。</p>
<p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f8jq4y27n2j30ly0m8gmu.jpg" alt=""></p>
<pre><code>public class FilesTest {
    public static void main(String[] args) {
        try {
            byte[] data = new byte[1];
            File srcFile = new File(&quot;1.txt&quot;);
            File desFile = new File(&quot;2.txt&quot;);
            BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(srcFile));
            BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(desFile));
            while (bufferedInputStream.read(data) != -1) {
                bufferedOutputStream.write(data);
            }
            bufferedOutputStream.flush();
            bufferedInputStream.close();
            bufferedOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>这里表现的是这个过程，IO文件里的数据经过文件输入流FileInputStream对象流入缓冲输入流BufferedInputStream对象，之后所有的数据(在数据量较小的时候，一般是小于8K时，后面会讨论到)流入输入流的缓冲区，之后每次在读取的时候都是直接从缓冲区读到临时的数组中去而不是再从流读入，然后临时数组的数据在write函数的作用下写到输出流的缓冲区中去，缓冲区满后数据会经由缓冲输出流BufferedOutputStream对象流入文件输出流FileOutputStream对象，并最终输出到IO文件中去，<strong>如果缓冲区不满的话是不会自发输出到缓冲输出流中去的，因此往往我们需要在最后缓冲区不满的情况下强制执行输出流的flush方法让缓冲区数据强制输出到输出流中去。</strong>这个过程完成了IO文件数据的流转，中间有一个缓冲区在暂存数据。</p>
<pre><code>public class FilesTest {
    public byte[] generateString() {
        StringBuffer buffer = new StringBuffer();
        String content = &quot;abcdefg\r\n&quot;;
        for (int i = 0; i &lt; 10000; i++) {
            buffer.append(content);
        }
        return buffer.toString().getBytes();
    }

    public static void main(String[] args) throws IOException {
        FilesTest filesTest = new FilesTest();
        byte[] buffer = filesTest.generateString();
        InputStream inputStream = new ByteArrayInputStream(buffer);
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        DataInputStream dataInputStream = new DataInputStream(inputStream);
        bufferedReader.readLine();
        System.out.println(dataInputStream.readline());
    }
}
</code></pre><p>在这个例子里我们可以更容易地发现BufferedReader这样的缓冲类输入流的缓冲作用，当首次调用readline(或者read等各种读取方法)函数读取这个输入流的时候，就会将流里的数据读进程序为BufferedInputStream对象分配的一个缓冲区中，而<strong>在此后的读取输入流的过程中就不需要去流中读取而只需要去缓冲区里读取就可以了，将开销较大的IO数据交换过程变成了开销小得多的内存数据交换</strong>，进而提高了IO效率，这是缓冲输入输出流的好处。但是这个缓冲区的大小是有限的，jdk为这个大小确定的固定值为8K字节，一旦超过这个值的话在第一次读取时就只能缓冲最多8K子节的数据，超出的部分只能在之后再缓冲。最后，如果要结束任务写入输出流的时候，要注意调用输出流的flush方法来将缓冲区强制清空使之全部输出到输出流中去。</p>
<pre><code>public class FilesTest {
    public static void main(String[] args) throws IOException {
        //buffer:8192    
        File src = new File(&quot;1.txt&quot;);
        File des = new File(&quot;2.txt&quot;);
        FileWriter writer = new FileWriter(src);
        StringBuffer buffer = new StringBuffer();
        for(int i = 0;i&lt;8193;i++){
            buffer.append(&quot;a&quot;);
        }
        writer.write(buffer.toString());
        writer.flush();
        BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(src));
        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(des));
        byte[] eachBuffer = new byte[1024];
        int haveRead;
        while((haveRead = bufferedInputStream.read(eachBuffer))!=-1){
            bufferedOutputStream.write(eachBuffer);
        }
        //bufferedOutputStream.flush();
    }
}
</code></pre><p>上面这个过程演示了缓冲区的大小，当输入流的内容填不满缓冲区时(也就是不足8192字节时)，如果不用flush没有办法自动写入文件，当原来缓冲区的大小大于这个值的时候，会一次性把上次的8192字节自动写入，下一次会再读入8192个字节，完成上面的过程。因此，这提醒我们，使用带有缓冲的输出流时务必要在最后强制清空缓冲进入输出流才能保证数据不出错。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/02/Java多线程基础/" itemprop="url">
                  Java多线程基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-02T15:22:13+08:00" content="2015-10-02">
              2015-10-02
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/10/02/Java多线程基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/02/Java多线程基础/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java多线程：Java多线程基础"><a href="#Java多线程：Java多线程基础" class="headerlink" title="Java多线程：Java多线程基础"></a>Java多线程：Java多线程基础</h1><h2 id="感性地理解一下什么是线程？"><a href="#感性地理解一下什么是线程？" class="headerlink" title="感性地理解一下什么是线程？"></a><strong>感性地理解一下什么是线程？</strong></h2><p>线程这个概念其实是比较抽象的，虽然依照教科书上的说法：</p>
<blockquote>
<p>进程是从系统获取资源的最小单位，线程是程序执行的最小单位。程序是静态存在于磁盘上的一段文本，进程运行这段文本记录的命令。</p>
</blockquote>
<p>也就是说，进程从系统那里获取到了一定的CPU占用时间片、内存单元和IO等等资源，然后线程将这些资源利用起来执行程序，线程执行程序是什么意思呢？就是把程序记录的那些命令逐条依序一步步在CPU上运作，数据在内存、IO上流转，将命令执行完。<br>这个层级的概念存在于OS上，OS的调度抽象层级并不是那么直观，如果我们在说明白一点，在做底层的计算机组成原理实验的时候，在我们接好连线后硬件就具有了处理数据的能力，只要扳动不同的开关就可以将数据读写在不同的芯片上，我们的程序也许是为了完成数据流转写在纸上的扳动不同开关的序列，所以程序是属于IO级别的，然后我们依照纸上的命令序列实际上手去扳动不同的开关执行的就是这段程序，所以我们自己充当的角色就是进程，最终就得出了这样的结论：进程“执行”程序。至于线程呢，可以看作是进程在执行过程中的策略，比如说在一个人扳动开关的时候就是单进程单线程，如果是两个人扳动开关就是单进程多线程，如果两个人能配合起来扳动开关就是多线程同步，所以线程和进程之间并非互斥的概念，而是相容的概念，如果有线程就一定有进程，一个进程包含了至少一个的线程。</p>
<h2 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a><strong>创建线程的方法</strong></h2><p>1.创建直接创建Thread的子类，重写run()方法；</p>
<pre><code>class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println(&quot;This is my thread&quot;);
    }
}

public class Test {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start();
    }
}
</code></pre><p>2.创建一个线程执行类实现Runnable接口，在这个执行类里实现Runnable的run()方法，创建该执行类的对象后，用此执行类对象初始化新线程，启动新线程时即执行这个执行对象的run()方法；</p>
<pre><code>class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;This is my thread&quot;);
    }
}

public class Test {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.start();
    }
}
</code></pre><p>3.通过线程工厂用工厂模式来创建新线程，新建工厂类继承ThreadFactory类重写newThread()方法，通过指定实现了Runnable接口的执行类来创建与之对应的线程；</p>
<pre><code>public class ThreadFactoryDemo {

    public static void main(String[] args) {
        ThreadFactory factory = new ThreadFactory() {

            @Override
            public Thread newThread(Runnable r) {
                // TODO Auto-generated method stub
                return new Thread(r);
            }
        };
        factory.newThread(new Runnable() {

            @Override
            public void run() {
                System.out.println(&quot;in runnable.&quot;);

            }
        }).start();
    }

}
</code></pre><p>注意：只有调用Thread类的Start方法，才能真正地在一个独立的线程中执行代码，直接调用Thread类的run方法，并不能启动一个新的线程，代码是在调用者线程中执行的。</p>
<p>那么主线程的run()方法在哪里呢？任何java程序的main执行入口担当着启动主线程的作用，只要进入了main函数就执行了主线程，因此整个main函数里的内容就是主线程的run()方法。</p>
<h2 id="线程究竟执行哪个run-方法"><a href="#线程究竟执行哪个run-方法" class="headerlink" title="线程究竟执行哪个run()方法"></a><strong>线程究竟执行哪个run()方法</strong></h2><p>当线程同时具有可执行对象实现的run()方法和线程重写的run()方法时，启动线程时究竟执行哪个run()方法呢？<br>结果是如果只定义了可执行对象的run()方法则执行这个run()方法，如果只重写了线程的run()方法则执行这个run()方法，如果两个方法都有则执行线程重写的run()方法。</p>
<pre><code>public class Test {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
                System.out.println(&quot;Runnable.run()&quot;);

            }
        }) {
            @Override
            public void run() {
                // TODO Auto-generated method stub
                System.out.println(&quot;Thread.run()&quot;);
            }
        };
        thread.start();
    }
}
</code></pre><h2 id="线程的休眠"><a href="#线程的休眠" class="headerlink" title="线程的休眠"></a><strong>线程的休眠</strong></h2><p>使用Thread类的sleep()方法或者使用TimeUnit的相关方法来休眠线程，休眠的意思是资源仍被占用，但是线程保留原来的状态没有活动；</p>
<pre><code>public class ThreadSleep {
    public static void main(String[] args) {
        Thread th = new Thread(new Runnable() {
            public void run() {
                for (int i = 0; i &lt; 10; i++) {
                    try {
                        // Thread.sleep(500);
                        TimeUnit.SECONDS.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }

        });
        th.start();
    }
}
</code></pre><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a><strong>线程中断</strong></h2><p>线程中断的意思是线程停止当前的运行状态让出资源结束生命周期，当外界想要一个线程中断时需要调用它的interrupted()方法，调用后不是直接就可以中断这个线程，而是将线程的interrupted标记位赋为1，如果要线程要响应这个中断则定期需要检查这个标记，检查到被中断标记后自己退出执行状态。</p>
<pre><code>public class ThreadInterruptDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread() {
            @Override
            public void run() {
                while (true) {
                    System.out.println(&quot;running&quot;);
                    if (isInterrupted())
                        return;
                }
            }
        };
        thread.start();
        Thread.sleep(2000);
        thread.interrupt();
    }
}
</code></pre><h2 id="线程定时任务"><a href="#线程定时任务" class="headerlink" title="线程定时任务"></a><strong>线程定时任务</strong></h2><p>线程要实现定时任务的话可以使用Runnable的实现类TimerTask，此类需要重写run()方法以完成具体需要进行的定时任务。然后由定时器Timer来调度，使用Timer的schedle()方法相当于启动这个定时任务线程。</p>
<pre><code>public class TimerTaskDemo {
    public static void main(String[] args) {

        TimerTask task = new TimerTask() {
            private int counter = 0;

            @Override
            public void run() {
                System.out.println(counter + &quot;:invoked!&quot;);
                counter++;
            }
        };
        Timer timer = new Timer();
        // 过2秒钟后首次运行，以后每隔3秒运行一次
        timer.schedule(task, 2000, 3000);
    }
}
</code></pre><h2 id="线程运行过程中的异常处理"><a href="#线程运行过程中的异常处理" class="headerlink" title="线程运行过程中的异常处理"></a><strong>线程运行过程中的异常处理</strong></h2><p>线程的run()方法中是不允许直接抛出异常的，也就是说不能有这样的写法：run() throws Exception ,原因在于在线程的运行过程中应该最大限度地保持正常工作，因此除了一些不可预知的运行时异常，不应该主动抛出受控异常。如果非要在run()方法里处理抛出的异常，则应该定义一个实现了UncaughtExceptionHandler的类，然后指定这个类的对象在重写的uncaughtException()方法里去处理抛出的异常。另外一种方法是，将这个线程加入一个线程组，在线程组里重写uncaughtException()方法来处理抛出的异常，这时线程组的作用相当于实现了UncaughtExceptionHandler的类。</p>
<p>1.使用handler对象处理异常：</p>
<pre><code>public class ThreadTest {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                throw new RuntimeException(&quot;格式错误&quot;);
            }
        });
        thread.setUncaughtExceptionHandler(new MyHandler());
        thread.start();
    }
}

class MyHandler implements UncaughtExceptionHandler {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println(t.getName() + &quot;:&quot; + e.getMessage());

    }
}
</code></pre><p>2.使用线程组处理异常：</p>
<pre><code>public class ThreadGroupDemo {
    public static void main(String[] args) {
        ThreadGroup threadGroup1 = new ThreadGroup(&quot;group1&quot;) {
            public void uncaughtException(Thread t, Throwable e) {
                System.out.println(t.getName() + &quot;: &quot; + e.getMessage());
            }
        };
        Thread thread1 = new Thread(threadGroup1, new Runnable() {
            public void run() {
                throw new RuntimeException(&quot;测试异常&quot;);
            }
        });

        thread1.start();
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/30/Java多线程执行框架/" itemprop="url">
                  Java多线程执行框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-30T15:20:22+08:00" content="2015-09-30">
              2015-09-30
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/09/30/Java多线程执行框架/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/30/Java多线程执行框架/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java多线程：Java多线程执行框架"><a href="#Java多线程：Java多线程执行框架" class="headerlink" title="Java多线程：Java多线程执行框架"></a>Java多线程：Java多线程执行框架</h1><h2 id="为什么需要执行框架呢？"><a href="#为什么需要执行框架呢？" class="headerlink" title="为什么需要执行框架呢？"></a><strong>为什么需要执行框架呢？</strong></h2><p>使用一般的new方法来创建线程有什么问题呢？一般的new线程的方式一般要给出一个实现了Runnable接口的执行类，在其中重写run()方法，然后再在将这个执行类的对象传给线程以完成初始化，这个过程中线程的定义和执行过程其实是杂糅在一起了，而且每次new一个新的线程出来在资源上很有可能会产生不必要的消耗，因此我们通过多线程执行框架来解决这两个问题，其一可以分离线程的定义和执行过程，其二可以通过线程池来动态地管理线程以减小不必要的资源开销。</p>
<h2 id="线程执行框架启动线程"><a href="#线程执行框架启动线程" class="headerlink" title="线程执行框架启动线程"></a><strong>线程执行框架启动线程</strong></h2><p>将要多线程执行的任务封装为一个Runnable对象,将其传给一个执行框架Executor对象, Executor从线程池中选择线程执行工作任务。</p>
<p>创建多线程框架对象调用线程执行任务<br>我们通常通过Executors类的一些静态方法来实例化Executor或ThreadPoolExecutor对象：</p>
<p>比如Executor对象来执行：</p>
<pre><code>public class ThreadTest {
    public static void main(String[] args) {
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(new MyRunnable());
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;running&quot;);
    }
}
</code></pre><p>比如线程池的Executor对象来执行：</p>
<pre><code>public class ThreadTest {
    public static void main(String[] args) {
        ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors
                .newFixedThreadPool(3);
        executor.execute(new MyRunnable());
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;running&quot;);
    }
}
</code></pre><ul>
<li>Executors. newSingleThreadExecutor()：一 个线程死掉后，自动重新创建后一个新的线程，所以没有线程池的概念，不能被ThreadPoolExecutor接收；</li>
<li>Executors. newFixedThreadPool()：固定数目的线程池；</li>
<li>Executors. newCachedThreadPool()：动态地增加和减少线程数；</li>
</ul>
<h2 id="多线程框架对象调用线程执行任务取回结果"><a href="#多线程框架对象调用线程执行任务取回结果" class="headerlink" title="多线程框架对象调用线程执行任务取回结果"></a><strong>多线程框架对象调用线程执行任务取回结果</strong></h2><p>实现了Runnable接口的执行类虽然可以在run()方法里写入执行体，但是无法返回结果值，因为run()方法是void型的，而Callable接口解决了这个问题，在继承了Callable接口的执行类中重写call()方法可以设置返回值，当Executor对象使用submit()函数提交执行类的时候会由线程池里的线程来运行，运行得到的返回值可以使用Future<v>接口来接，取得的返回值类型由V决定，Future<v>接口表示可能会得到的返回值，但是有可能报异常，因此要抛出这些异常，然后可以取得这些返回值。</v></v></p>
<pre><code>public class ThreadTest {
    public static void main(String[] args) throws InterruptedException,
            ExecutionException {
        ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors
                .newCachedThreadPool();
        MyCallable myCallable = new MyCallable(2);
        Future&lt;Integer&gt; result = executor.submit(myCallable);
        System.out.println(result.get());
    }
}

class MyCallable implements Callable&lt;Integer&gt; {
    private int num;

    public MyCallable(int num) {
        this.num = num;
    }

    @Override
    public Integer call() throws Exception {
        return num * 2;
    }
}
</code></pre><h2 id="多线程框架对象调用线程执行任务完成第一个还是全部完成就取回结果"><a href="#多线程框架对象调用线程执行任务完成第一个还是全部完成就取回结果" class="headerlink" title="多线程框架对象调用线程执行任务完成第一个还是全部完成就取回结果"></a><strong>多线程框架对象调用线程执行任务完成第一个还是全部完成就取回结果</strong></h2><p>使用submit()函数取回的结果不能控制任务是完成第一个还是全部完成就取回结果，然而使用invokeAny()和invokeAll()函数即可获得这样的效果，将执行体对象放入集合中传入这两个函数，前者可以在完成任务的多线程有一个(第一个)完成时就返回结果，因此结果类型是单结果，而后者则需要等待所有执行任务的线程都执行完毕才返回结果，因此结果仍是集合。</p>
<p>1.invokeAny():</p>
<pre><code>public class ThreadTest {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(5);
List&lt;MyCallable&gt; callables = new ArrayList&lt;&gt;();
for(int i=0;i&lt;10;i++){
MyCallable myCallable = new MyCallable(i);
callables.add(myCallable);
}
Integer res = executor.invokeAny(callables);
System.out.println(res);

}
}

class MyCallable implements Callable&lt;Integer&gt; {
    private int num;

    public MyCallable(int num) {
        this.num = num;
    }

    @Override
    public Integer call() throws Exception {
        System.out.println(Thread.currentThread().getName() + &quot; is running&quot;);
        return num * 2;
    }
}
</code></pre><p>2.invokeAll():</p>
<pre><code>public class ThreadTest {
    public static void main(String[] args) throws InterruptedException,
            ExecutionException {
        ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors
                .newFixedThreadPool(5);
        List&lt;MyCallable&gt; callables = new ArrayList&lt;MyCallable&gt;();
        for (int i = 0; i &lt; 10; i++) {
            MyCallable myCallable = new MyCallable(i);
            callables.add(myCallable);
        }
        List&lt;Future&lt;Integer&gt;&gt; res = executor.invokeAll(callables);
        for (Future&lt;Integer&gt; future : res) {
            System.out.println(future.get());
        }
    }
}

class MyCallable implements Callable&lt;Integer&gt; {
    private int num;

    public MyCallable(int num) {
        this.num = num;
    }

    @Override
    public Integer call() throws Exception {
        System.out.println(Thread.currentThread().getName() + &quot; is running&quot;);
        return num * 2;
    }
}
</code></pre><h2 id="多线程框架对象执行定时任务"><a href="#多线程框架对象执行定时任务" class="headerlink" title="多线程框架对象执行定时任务"></a>多线程框架对象执行定时任务</h2><p>使用Executor的schedule()函数族来调度线程池中的线程来执行callable执行类对象中的call()定时任务:</p>
<pre><code>public class ThreadTest {
    public static void main(String[] args) throws InterruptedException,
            ExecutionException {
        ScheduledExecutorService executorService = Executors
                .newScheduledThreadPool(2);
        MyCallable callable = new MyCallable(2);
        executorService.schedule(callable, 10, TimeUnit.SECONDS);
        executorService.shutdown();
    }
}

class MyCallable implements Callable&lt;Integer&gt; {
    private int num;

    public MyCallable(int num) {
        this.num = num;
    }

    @Override
    public Integer call() throws Exception {
        System.out.println(Thread.currentThread().getName() + &quot; is running&quot;);
        return num * 2;
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/30/Java多线程同步与synchronized/" itemprop="url">
                  Java多线程同步与synchronized
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-30T15:17:15+08:00" content="2015-09-30">
              2015-09-30
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/09/30/Java多线程同步与synchronized/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/30/Java多线程同步与synchronized/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java多线程：Java多线程同步与synchronized"><a href="#Java多线程：Java多线程同步与synchronized" class="headerlink" title="Java多线程：Java多线程同步与synchronized"></a>Java多线程：Java多线程同步与synchronized</h1><h2 id="为什么需要同步多线程？"><a href="#为什么需要同步多线程？" class="headerlink" title="为什么需要同步多线程？"></a><strong>为什么需要同步多线程？</strong></h2><p>线程的同步是指让多个运行的线程在一起良好地协作，达到让多线程按要求合理地占用释放资源。我们采用Java中的同步代码块和同步方法达到这样的目的。比如这样的解决多线程无固定序执行的问题：</p>
<pre><code>public class TwoThreadTest {
        public static void main(String[] args) {
              Thread th1= new MyThread1();
              Thread th2= new MyThread2();
              th1.start();
              th2.start();
       }
}

class MyThread2 extends Thread{
        @Override
        public void run() {
               for( int i=0;i&lt;10;i++)
                     System. out.println( &quot;thread 1 counter:&quot;+i);
       }
}

class MyThread1 extends Thread{
        @Override
        public void run() {
               for( int i=0;i&lt;10;i++)
                     System. out.println( &quot;thread 2 counter:&quot;+i);
       }      
}
</code></pre><p>这种状态下多线程执行的结果是随机地去任意插入执行，这完全取决于JVM对于线程的调度，在很多要求定序执行的情况下，这种随机执行的状态显然是不合要求的。</p>
<pre><code>public class ThreadTest {
        public static void main(String[] args) {
              MyThread thread = new MyThread();
              Thread th1= new Thread(thread);
              Thread th2= new Thread(thread);
              th1.start();
              th2.start();
       }

}

class MyThread implements Runnable{
        @Override
        public synchronized void run() {
               for( int i=0;i&lt;10;i++)
                     System. out.println(Thread. currentThread().getName()+&quot; counter:&quot;+i);
       }
}
</code></pre><p>使用了同步方法后我们就可以控制线程独占执行体对象，这样在执行的过程中就可以使得线程将执行体上的任务一次性执行完后退出锁定状态，JVM再调度另一个线程进来一次性运行执行体内的任务。</p>
<h2 id="线程创建运行的范式"><a href="#线程创建运行的范式" class="headerlink" title="线程创建运行的范式"></a><strong>线程创建运行的范式</strong></h2><p>在以前我们也有自己的线程创建和运行的编程范式，一般是定义一个执行类重写run()方法，但是这种方式将执行体和执行的任务放在了一起，从软件工程的角度来看不利于解耦。一个线程的执行的意思是说线程通过执行对象执行了某个对象的某个任务，从这个角度来说，将任务的规定者从执行类中分离出来可以使得多线程编程的各个角色明晰出来，进而获得良好地解耦，以下就是线程创建和执行的编程范式：</p>
<pre><code>public class FormalThreadClass {
        public static void main(String[] args) {
              Thread thread = new Thread( new MyRunnable());
              thread.start();
       }
}

class MyRunnable implements Runnable{
       MyTask myTask = new MyTask();
        @Override
        public void run() {
               myTask.doTask();
       }
}

class MyTask{
        public void doTask() {
              System. out.println( &quot;This is real Tasking&quot;);
       }
}
</code></pre><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a><strong>synchronized关键字</strong></h2><p>synchronized可以用来修饰方法以构成同步方法，还可以修饰对象构成同步代码块，最终的目的都是一样的：<br>给要访问数据的线程添加一个规定：一次只允许一个线程访问数据。只有?当前正在访问数据”的线程结束访问之后，其他线程才允许访问这个数据。</p>
<p>关于synchronized关键字，有以下几点来说明：</p>
<ol>
<li><p>当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p>
</li>
<li><p>当两个并发线程访问同一个对象object中的这个synchronized同步代码块或同步方法时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块或同步方法以后才能执行该代码块或同步方法。</p>
</li>
<li><p>然而，当一个线程访问object的一个synchronized同步代码块或同步方法时，另一个线程仍然可以访问该object中的非synchronized同步代码块或非synchronized同步方法。</p>
</li>
<li><p>尤其关键的是，当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程对object中所有其它synchronized同步代码块或同步方法的访问将被阻塞。</p>
</li>
</ol>
<h3 id="1-以下这个例子可以说明synchronized方法的这些特性，同步代码块也是一样："><a href="#1-以下这个例子可以说明synchronized方法的这些特性，同步代码块也是一样：" class="headerlink" title="1. 以下这个例子可以说明synchronized方法的这些特性，同步代码块也是一样："></a>1. 以下这个例子可以说明synchronized方法的这些特性，同步代码块也是一样：</h3><p>① synchronized方法表面上它只是锁定了当前的方法本身，实际上当synchronized方法起作用的时候，整个对象的带有synchronized的方法都将被锁定，这也就是为什么当一个线程执行一个synchronized方法时，其他的线程除了不能访问当前的同步方法外还并不能访问其他的同步方法，而只能访问非synchronized方法，因为这种锁定是对象级别的。</p>
<pre><code>public class ThreadTest {
        public static void main(String[] args) {
               final MyTask myTask = new MyTask();
              Thread thread1 = new Thread( new Runnable() {
                      public void run() {
                           myTask.doTask1();
                     }
              });
              Thread thread2 = new Thread( new Runnable() {
                      public void run() {
                           myTask.doTask2();
                     }
              });
              thread1.start();
              thread2.start();
       }
}

class MyTask{
        public synchronized void doTask1() {
               for ( int i = 0; i &lt; 5; i++) {
                     System. out.println( &quot;1 This is real Tasking &quot;+i);
              }
       }
        public void doTask2() {
               for ( int i = 0; i &lt; 5; i++) {
                     System. out.println( &quot;2 This is real Tasking &quot;+i);
              }
       }
}
</code></pre><p>② 如使在静态方法中用synchronized时，因为这个方法就不是仅属于某个对象而是属于整个类的了，所以一旦一个线程进入了这个代码块就会将这个类的所有对象的所有synchronized方法或synchronized同步代码块锁定，其他的线程就没有办法访问所有这些对象的synchronized方法和synchronized代码块（注意其他线程还是仍然能访问这些对象的非synchronized方法和synchronized代码块的），因此这种锁定是class级别的。</p>
<pre><code>public class FormalThreadClass {
        public static void main(String[] args) {
              MyTask myTask1 = new MyTask();
              MyTask myTask2 = new MyTask();
              Thread thread1 = new Thread( new MyRunnable(myTask1));
              Thread thread2 = new Thread( new MyRunnable(myTask2));
              thread1.start();
              thread2.start();
       }
}

class MyRunnable implements Runnable {
       MyTask myTask;
        public MyRunnable(MyTask myTask) {
               this. myTask = myTask;
       }
        @Override
        public void run() {
              MyTask. doTask();
       }
}

class MyTask {
        public static synchronized void doTask() {
               for ( int i = 0; i &lt; 5; i++) {
                     System. out.println(Thread. currentThread().getName()+&quot; running &quot;+i);
              }
       }
}
</code></pre><h3 id="2-synchronized同步代码块是对一个对象作为参数进行锁定。"><a href="#2-synchronized同步代码块是对一个对象作为参数进行锁定。" class="headerlink" title="2. synchronized同步代码块是对一个对象作为参数进行锁定。"></a>2. synchronized同步代码块是对一个对象作为参数进行锁定。</h3><p>① 如在使用synchronized(this)时，一旦一个线程进入了这个代码块就会将整个对象的所有synchronized方法或synchronized同步代码块锁定，其他的线程就没有办法访问这个对象的synchronized方法和synchronized代码块（注意其他线程还是仍然能访问这个对象的非synchronized方法和synchronized代码块的）。</p>
<pre><code>public class ThreadTest {
        public static void main(String[] args) {
               final MyTask myTask = new MyTask();
              Thread thread1 = new Thread( new Runnable() {
                      public void run() {
                           myTask.doTask1();
                     }
              });
              Thread thread2 = new Thread( new Runnable() {
                      public void run() {
                           myTask.doTask2();
                     }
              });
              thread1.start();
              thread2.start();
       }
}

class MyTask {
        public void doTask1() {

               synchronized (this) {
                      for ( int i = 0; i &lt; 5; i++) {
                           System. out.println( &quot;1 is running&quot;);
                     }
              }

       }

        public void doTask2() {
               for ( int i = 0; i &lt; 5; i++) {
                     System. out.println( &quot;2 is running&quot;);
              }
       }
}
</code></pre><p>所以：synchronized方法实际上等同于用一个synchronized块包住方法中的所有语句，然后在synchronized块的括号中传入this关键字。当然，如果是静态方法，需要锁定的则是class对象。</p>
<p>① 如在使用synchronized(<strong>.class)时，一旦一个线程进入了这个代码块就会将整个类的所有这个synchronized(</strong>.class) 同步代码块锁定，其他的线程就没有办法访问这个对象的synchronized(**.class) 代码块，这种锁也是class级别的，但要注意在这种情况下，其他线程仍然是可以访问仅做了synchronized的代码块或非静态方法的，因为它们仅仅是对当前对象的锁定。</p>
<pre><code>public class FormalThreadClass {
        public static void main(String[] args) {
              MyTask myTask1 = new MyTask();
              MyTask myTask2 = new MyTask();
              Thread thread1 = new Thread( new MyRunnable(myTask1));
              Thread thread2 = new Thread( new MyRunnable(myTask2));
              thread1.start();
              thread2.start();
       }
}

class MyRunnable implements Runnable {
       MyTask myTask;
        public MyRunnable(MyTask myTask) {
               this. myTask = myTask;
       }
        @Override
        public void run() {
               myTask.doTask();
       }
}

class MyTask {
        public  void doTask() {
               synchronized (MyTask.class ) {
                      for ( int i = 0; i &lt; 5; i++) {
                           System. out.println(Thread. currentThread().getName()+&quot; running &quot;+i);
                     }
              }
       }
}
</code></pre><p><strong>总结起来这一部分：</strong><br>synchronized方法是一种粗粒度的并发控制手段，某一时刻只能有一个线程执行该方法。synchroized块则是一种细粒度的并发控制，只会将块中的代码同步，位于方法内synchroized块之外的代码是可以被多个线程同时访问到。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/19/黑客与画家/" itemprop="url">
                  黑客与画家
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-19T00:17:11+08:00" content="2015-09-19">
              2015-09-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/09/19/黑客与画家/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/19/黑客与画家/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这两周重新阅读了这本经典，很难有这样的机会认认真真地做一次深度的阅读，所以把读书的笔记发到博客上。</p>
<p>这本书的风格很奇怪，因为你很难相信一个人可以把有些稀松平常的事看得如此透彻而且富有深层的意义，那些小事在我们平常人看来可能不值一提，然而在作者笔下你可以跟随他的指引接近一些独特的视角，把这些隐秘挖掘出来，得出一些令人惊奇的结论。</p>
<p><img src="https://img3.doubanio.com/lpic/s4669554.jpg" alt=""></p>
<h2 id="第一部分-成长和思想"><a href="#第一部分-成长和思想" class="headerlink" title="第一部分 成长和思想"></a>第一部分 成长和思想</h2><p>黑客是如何成长的以及他们看待世界的一些观点。</p>
<h3 id="第一章-为什么书呆子不受欢迎"><a href="#第一章-为什么书呆子不受欢迎" class="headerlink" title="第一章 为什么书呆子不受欢迎"></a>第一章 为什么书呆子不受欢迎</h3><p>一个问题是，为什么书呆子不受欢迎呢？一个看似简单的问题，却在做着一层层的分析之后让人看到一个从学生圈子直指教育体系存在的大问题。作者在这一部分大致说明了以下的观点：</p>
<ul>
<li><p>学生独特的圈子逻辑和社会中的成年人而言是一种完全隔绝开的难以令成年人理解的逻辑。</p>
</li>
<li><p>在学生圈子里最被看重的东西是获得吸引力，表现的受欢迎可以赢得更多人的支持并最终在圈子里成为winner。</p>
</li>
<li><p>书呆子们往往由于无暇顾及这些而失去吸引力，在圈子里渐渐受到孤立，他们的精力会集中在其他东西上。</p>
</li>
<li><p>真实的成年人社会与这个学生圈子执行完全不同的逻辑，它没有古怪的游戏规则，你的能力和聪明将带来价值，和是否获得吸引力无关。</p>
</li>
<li><p>学生时代因为无暇顾及吸引力的书呆子在这个真实的成年人社会里如鱼得水，用自己的能力创造的价值将令他们获得欢迎。</p>
</li>
<li><p>教育制度里存在的问题是成年人们往往不理解学生圈子和成年人社会的逻辑的天然隔绝而放任其自流，最终导致学生圈子里的游戏愈加无法理解，书呆子们因此而苦恼。</p>
</li>
<li><p>解决这个问题的方法也许就是告诉那些所谓的“书呆子”他们兴趣所在的重要性，他们所处的圈子并未真实，像大学一样来培养他们，让他们明白能力创造价值的存在。</p>
<p>这一章作为开篇，“黑客”们的学生时代的成长困惑 是一个关乎学习和智力的问题。</p>
</li>
</ul>
<h3 id="第二章-黑客与画家"><a href="#第二章-黑客与画家" class="headerlink" title="第二章 黑客与画家"></a>第二章 黑客与画家</h3><p>作者有着黑客与画家的双重身份，外似没什么特别关系的两个领域在作者的重重分析后却显现出出奇的相似。在这一部分，作者阐述了很多新奇的观点：</p>
<ul>
<li><p>黑客既不同于完全痴迷于理论研究的计算机科学家，也不同于只擅长于完成产品经理构想的软件工程师，而是一种极富创造力的存在。</p>
</li>
<li><p>黑客的创作过程不应该是循规蹈矩地纸上谈兵，更应该是在实践中激发想法得出完美的结果，这和从完美成果出发得出原创的科学家相比截然不同，却和涂涂改改的画家相同。</p>
</li>
<li><p>像画家以画肖像画糊口一样，黑客们在白天使用程序工具来糊口，像画家在业余时间创作一样，黑客们在晚上创造自己完美的作品。</p>
</li>
<li><p>像画家临摹名作和改改画画来学习绘画一样，黑客们通过查看优秀作品的源程序并且在创作过程中不断修正自己的代码来学习提升自己的能力。</p>
</li>
<li><p>像画家一丝不苟追求自己作品的全部细节一样，优秀的黑客应该追求自己代码的完美，针对自己的心理预期去调整自己的创作节奏。</p>
</li>
<li><p>画家的合作讲求每个人负责绘制一个相对完整的小部分，而黑客们的合作与此类似的，是各自负责编写一个独立完整的小模块。</p>
</li>
<li><p>像画家的作品和其人流芳百世一样，黑客们的现在正是画家们曾经遇到过的，通过充分探索将编程的价值发挥到极致，成为后辈们敬仰的对象。</p>
</li>
</ul>
<h3 id="第三章-不能说的话"><a href="#第三章-不能说的话" class="headerlink" title="第三章 不能说的话"></a>第三章 不能说的话</h3><p>这一部分作者提出了一些关于获得正确思想的方法论，这些方法论对规避道德规范上的被强制输入有很强的实践意义。这些方法论概括起来就是：</p>
<ul>
<li><p>我们需要去判断所听到的言论的真伪，那些看起来是真的话是否确实是真的。</p>
</li>
<li><p>关注那些极富争议性的话，那些被贴着标签的话真的符合那些标签吗？</p>
</li>
<li><p>将当代的观点和不同时期的古代的观点或者同一时期的不同地点做个对比，可能就会发现当代的某些观点也许并不是不可接受。</p>
</li>
<li><p>看看对于不可言说的话的捍卫者的动机，他们究竟在捍卫什么，捍卫的目的又是为了什么。</p>
</li>
<li><p>观察一种言语禁忌背后的形成机制，负责言语禁忌的团体究竟是怎样的一种力量。</p>
</li>
</ul>
<p>至于说为什么我们要去寻找这些不能说的话，作者这样认为：</p>
<ul>
<li><p>训练我们思考问题的方法，这种看起来没有什么太大意义的思考往往可以训练独特地思维方式。</p>
</li>
<li><p>发现的不能说的话的态度，应该是在没有必要因此而争执的时候就守口如瓶，否则将会陷入不必要的麻烦之中。</p>
</li>
</ul>
<h3 id="第四章-良好的坏习惯"><a href="#第四章-良好的坏习惯" class="headerlink" title="第四章 良好的坏习惯"></a>第四章 良好的坏习惯</h3><p>这一部分作者向我们展示了什么是黑客追求的自由精神，自由查看所有能够认清事物运行原理和机制是黑客们发展新技术的基础。然而随着法律和版权保护的转机的出现，这种自由被大大限制，黑客们这种良好的坏习惯难以为继，而这种良好的坏习惯往往也就是美国精神的源泉。</p>
<h2 id="第二部分-成果和影响"><a href="#第二部分-成果和影响" class="headerlink" title="第二部分 成果和影响"></a>第二部分 成果和影响</h2><p>黑客怎样做出自己的成果，这些成果又是怎样对全世界产生了影响。</p>
<h3 id="第五章-另一条路"><a href="#第五章-另一条路" class="headerlink" title="第五章 另一条路"></a>第五章 另一条路</h3><p>这一部分，作者借自己开发viaweb这一互联网软件服务的经历来阐述了自己对于新一代的软件服务的看法，这些看法总结起来如下：</p>
<ul>
<li><p>和桌面软件留给用户的复杂和麻烦相比，互联网软件把这些复杂的管理过程留给了幕后的开发人员，留给用户的只是方便的操作，这会大大减小用户的压力。</p>
</li>
<li><p>对于开发互联网软件的开发人员来说，庞大的软件系统和硬件设施可以按照他们想要的方式灵活地运行。</p>
</li>
<li><p>快速迭代的互联网软件可以更快发现更早解决各种bug，而且会大大减少bug出现的可能性，和桌面软件相比在bug的处理方面更具优势。</p>
</li>
<li><p>客户使用互联网软件的过程其实也就是为这个系统作出测试和找到bug的过程，这个过程还能够大大促进客户、客服和开发人员之间的合作交流，往往这些爆出的bug也能够及早地解决掉。</p>
</li>
<li><p>全身心投入开发的开发人员们会不由自主地把自己的想法快速实现，长远的计划会在一次次的迭代后成为功能。</p>
</li>
<li><p>小而美的团队是互联网软件团队的最佳搭配，快速响应的团队能够最大限度地减小复杂会议带来的沟通弊端。</p>
</li>
<li><p>用户的行为产生的价值远远好过模拟的测试结果，关注用户的行为能够产生更符合他们心里预期的产品。</p>
</li>
<li><p>好的互联网软件服务的策略应该是订阅模式而不应该是一次性的授权，这种模式将会带来一个持续的现金流。</p>
</li>
<li><p>互联网软件服务提供公司应该比接受他们服务的公司本身更注重安全和服务的质量，只有这样才能让后者能够放心地接受这样的服务。</p>
</li>
<li><p>围绕桌面电脑，早起的黑客自此发展起自己的软件，而现在的黑客则可以围绕家家户户的个人电脑和网络搭建起他们的互联网软件服务，而且这个过程和操作系统本身无关。</p>
</li>
<li><p>微软和创业公司，对于前者，互联网软件可能会是对它的一个重大挑战，这将大大地挑战它的商业模式和技术基础，而对于后者，这将是一个大大的机会，他们将有机会以更小的力量创造更伟大的产品。</p>
</li>
<li><p>互联网软件构建技术本身有着重重的问题，和功能更为强大的桌面软件工具相比有很大劣势，但这恰恰是一个提供给创业公司的一个机遇。</p>
</li>
<li><p>运作一家创业公司没有黑客们想象的那们困难，保证营收的收支平衡，技术和产品最终带来的用户产生的价值将会使产品走向正轨。大公司和创业公司相比，也许会更有资产，但是缺乏新技术本身带给产品的开发效率和灵活过程。</p>
</li>
</ul>
<h3 id="第六章-如何创造财富"><a href="#第六章-如何创造财富" class="headerlink" title="第六章 如何创造财富"></a>第六章 如何创造财富</h3><p>作者所说的财富并不简单的是指金钱，对于一个公司而言，财富是他们所创造的那些能够满足他们的用户的需要的产品所蕴含的价值，这种价值一旦被创造，传统意义上的财富就会随之而来。关于财富的创造，作者提出了这些观点：</p>
<ul>
<li><p>创业公司高速创造财富的背后是所有员工能够高效率辛苦的长期工作，巨大的压力和高强度的工作使员工能够获得高额的报酬。</p>
</li>
<li><p>财富的总价值并不是一成不变的，为社会创造出的价值将会变成公司的财富来源，公司里的员工们通过辛苦的工作创造的财富将会为社会带来总价值的增加。</p>
</li>
<li><p>工作的本质和目的就是在一个组织中和人合作创造财富的过程，重点在于做出人们需要的东西而非简单的劳动。</p>
</li>
<li><p>作者提及了两个非常重要的公司运行过程中的特征：可测量性和可放大性：一个小的团体更能对团体中每个个体的可测量性作出评估，因为每个人的行为对整个团队的影响都会清晰地显现；可放大性体现在采用高技术方法产生的产品将会带动整个行业，同时高技术将会拉开与竞争对手的距离。然而创业公司正好符合这两个特征，一个小而精 的团队最终将灵活高效地运作，同时能够通过高技术使得迟缓行动的大公司难以追击。</p>
</li>
<li><p>创业背后的潜规则就是：真正成功地运作一个创业公司困难重重，能够存活下来的创业公司少之又少，如果想要保险，那么做法可能就是卖掉它。</p>
</li>
<li><p>用户的态度和使用习惯事最重要的，解决他们的问题是公司创造财富的最终目的。</p>
</li>
<li><p>高回报的激励最终会使得创业公司去解决过去看起来困难重重的问题，而技术革新带来的财富是致富的范例。最终，黑客们通过自己的努力获得了财富的积累，良性的循环将产生更大的财富造福社会。</p>
</li>
</ul>
<h3 id="第七章-关注贫富分化"><a href="#第七章-关注贫富分化" class="headerlink" title="第七章 关注贫富分化"></a>第七章 关注贫富分化</h3><p>这一部分作者讨论了社会整体出现贫富分化差异的原因和可能会产生的意义，以及贫富分化将给社会发展注入的动力。下面是这一部分作者的一些观点：</p>
<ul>
<li><p>父辈们理解的财富应该是一成不变的总量不会变化的东西，所以他们会很容易认为财富分配出现不均，然而事实上财富是不同人根据不同能力创造出来的，因此它就天生具有不公平性。</p>
</li>
<li><p>偷窃在财富转移上是个广义的概念，通过非创造的、不义的形式达到财富转移的过程都该算是偷窃，然而随着财富创造的人们的出现，偷窃没有真正创造财富的过程富有竞争力，所以社会向着正义和有价值的方向发展。</p>
</li>
<li><p>通过技术的进步和掌握技术，创造财富带来的价值和为社会带来的影响更大，同时技术在大多数方面能够使得贫富分化和社会地位看起来变得不那么严重。</p>
</li>
<li><p>贫富分化和收入差异带来的社会问题并不全都是坏事，因为创造财富的人收获的巨大收入将吸引他们继续完成更伟大的创造，同时使得整个社会快速发展。</p>
</li>
</ul>
<h3 id="第八章-防止垃圾邮件的一种方法"><a href="#第八章-防止垃圾邮件的一种方法" class="headerlink" title="第八章 防止垃圾邮件的一种方法"></a>第八章 防止垃圾邮件的一种方法</h3><p>这一部分作者提到了自己通过技术思维解决垃圾邮件的过滤问题。这里作者提供了几个很有意思的办法，后面的比要比前面的更具技术思维：</p>
<ul>
<li><p>恶意关键字过滤器：通过扫描邮件里出现的是否频繁一些看起来像是具有垃圾邮件特征的标记来对邮件作出判断 。</p>
</li>
<li><p>统计学过滤器：通过大样本来让系统学习什么样的标志符意味着着邮件是垃圾邮件的高概率，通过大样本的分析，系统最终会动态修正以完成判断。</p>
</li>
<li><p>贝叶斯方法：对邮件进行分析，所有的线索都有对应的得分，分析结束后获得的总分将会说明它是垃圾邮件的肯能性高低。同时，加入邮件头和主动关键字省略，将会使这种方法的可靠性大大增加。</p>
</li>
</ul>
<p>最后，作者提到了垃圾邮件过滤的目的：过滤的最终目的就是让发送这些邮件的商家意识到效果并不好以最终放弃。</p>
<h3 id="第九章-设计者的品味"><a href="#第九章-设计者的品味" class="headerlink" title="第九章 设计者的品味"></a>第九章 设计者的品味</h3><p>这一部分作者谈了谈一个很学术的问题，好设计是什么？好设计的特征是什么？好的设计是美，是有品味的，公认的好设计应该有这些特征：</p>
<ul>
<li><p>简单。当设计只直视本质、忽略无关的时候，设计者会加倍认真地进行创作。</p>
</li>
<li><p>永不过时。无论过去、现在还是未来的人们都认同的设计能够避开风潮、充满永恒的吸引力。</p>
</li>
<li><p>解决主要问题。这是设计的主要目的。</p>
</li>
<li><p>启发性。使用者可以在设计的原基础上充分拓展实现他们自己的想法。</p>
</li>
<li><p>些许趣味。幽默的设计反映了一种特别的力量。</p>
</li>
<li><p>艰苦和看似容易。经过努力艰苦的层层磨难得到的结论拥有简洁和看似容易的结果，而这样的结果往往具有难以被打破的完美。</p>
</li>
<li><p>对称。这往往意味着结构的简洁和美妙。</p>
</li>
<li><p>对大自然的模仿。大自然的演化趋向于成就完美的设计，追随大自然的设计无疑就是找到完美设计的一个途径。</p>
</li>
<li><p>再设计。在原有不好的设计上重新设计，把这些问题解决使之成为好设计的一部分。</p>
</li>
<li><p>能够被复制。优秀的部分具有复用的价值。</p>
</li>
<li><p>奇特。奇特往往意味着聪明、思维和风格。</p>
</li>
<li><p>成批出现。优秀的人们会聚在一起形成好设计的形成中心并形成好设计的新趋势。</p>
</li>
<li><p>大胆。今天看似大胆甚至错误的结论很有可能是明天的新理论。</p>
</li>
</ul>
<h2 id="第三部分-工具和方法"><a href="#第三部分-工具和方法" class="headerlink" title="第三部分 工具和方法"></a>第三部分 工具和方法</h2><p>解释了黑客的工具(编程语言)和工作方法,这是黑客文化的基础和核心。</p>
<h3 id="第十章-编程语言解析"><a href="#第十章-编程语言解析" class="headerlink" title="第十章 编程语言解析"></a>第十章 编程语言解析</h3><p>这一章作者开始介绍黑客们手中的利剑－－编程语言。从编程语言从底层到应用分别介绍了它的前世今生。</p>
<ul>
<li><p>机器语言和汇编语言更像是直接对机器的操纵，程序员们需要从很机器的层面编写程序。</p>
</li>
<li><p>高级语言是对机器语言的高度封装，通过编译器或者解释器这一将高级语言翻译成机器语言的助手，程序员的工作难度大大降低，他们只需要关注功能而非复杂的指令本身。</p>
</li>
<li><p>开放源码的措施能够让所有有能力编程的用户及早发现解决问题，提升软件的可靠性。</p>
</li>
<li><p>编程语言孰优孰劣的问题本身就像一场战争，语言之间巨大的差异注定很难去判断谁是最好的语言。</p>
</li>
<li><p>底层的语言能够最大限度地直接和机器交流，因此可以获得最大的效率，同时，封装后对于程序员友好的高级语言的效率就低得多了。</p>
</li>
<li><p>静态语言能够有效地解决类型错误带来的bug，让绝大多数的程序员避免这种问题，而动态语言自由的特性决定了使用者需要更强的掌控能力。</p>
</li>
<li><p>面向对象编程改变了以往过程化语言的程序结构组织，这种风格一方面可以使得程序的结构性更易读，同时也限制了编程的风格。</p>
</li>
<li><p>现在的时代就像是编程语言的文艺复兴，大批的编程语言冒了出来，很多语言的内核设计也许并不完善，但是在社区力量的驱动下有足够有效的第三方库的支持使得这些语言在解决问题时变的有效。</p>
</li>
</ul>
<h3 id="第十一章-一百年后的编程语言"><a href="#第十一章-一百年后的编程语言" class="headerlink" title="第十一章 一百年后的编程语言"></a>第十一章 一百年后的编程语言</h3><p>一个有趣的设想是编程语言进化到一百年后会是什么样子？抓到编程语言的发展主干是预测的基础。作者看来，具有最干净内核的语言最终将有更强的生命力。</p>
<ul>
<li><p>未来计算机本身具有的更强大计算能力将为编程语言带来更多的机会。</p>
</li>
<li><p>更高的速度带来的优势很有可能会被更消耗硬件资源的编程语言所“浪费”，因为语言实现的效率往往是对计算资源的消耗，看似友好的背后往往意味着更多的处理。</p>
</li>
<li><p>设计编程语言应该尝试对实现少做限制加大灵活性，虽然这样做可能具有很低的效率，但是对于语言内核简洁的实现大有好处。</p>
</li>
<li><p>采用多层设计会影响这种语言的性能，但是会很利于修改。应用程序的多层开发也是一种很常见的技巧，会给系统带来可重用性，对于企业软件来说，加上面向对象编程，多层设计非常有利于软件的迭代和持续性。</p>
</li>
<li><p>关于并行计算，作者认为在大多数领域并不会成为主流，因为如果过早使用并行计算很有可能产生过早优化的问题。</p>
</li>
<li><p>新语言将会更多地以开源项目的形式出现，而且作者们可能只是这些语言的使用者而非这些语言的编译器的作者。</p>
</li>
<li><p>如果想要创造出属于未来的更好的编程语言，我们应该摒弃那些旧有语言带来的定势，突破这些去创造全新的习惯，在今天就可以在不考虑编译器的情况下创造新的编程语言。</p>
</li>
</ul>
<h3 id="第十二章-拒绝平庸"><a href="#第十二章-拒绝平庸" class="headerlink" title="第十二章 拒绝平庸"></a>第十二章 拒绝平庸</h3><p>这一章作者用自己的经历讲述了在技术领域使用不平常的工具和编程语言将带来什么样的意义。作者的创业项目使用了普通开发者并不会常使用的Lisp，这一技术方案最终能够使作者的项目能够快速开发以打倒竞争助手的新功能最终制胜。</p>
<ul>
<li><p>Blub困境，一般的程序员很容易满足自己长期使用的编程语言，因此会陷入不再了解新技术、新语言的困境。</p>
</li>
<li><p>使用功能强大的语言能够出其不意地削弱竞争对手的优势，因为他们深陷于Blub困境中不思进取。</p>
</li>
</ul>
<h3 id="第十三章-书呆子的复仇"><a href="#第十三章-书呆子的复仇" class="headerlink" title="第十三章 书呆子的复仇"></a>第十三章 书呆子的复仇</h3><p>这一部分作者向我们展示了使用高级而且出色的工具将为黑客在工程上带来如何优秀的表现。以Lisp为例，作者表达了这一先进的语言在当今软件行业的竞争中制胜的奥秘：</p>
<ul>
<li><p>和其他编程语言以机器发展相关的特性，Lisp是一个数学模型转变来的语言，优秀的理论特性最终使得Lisp在发展中从理论上的完美变成实践中的完美。</p>
</li>
<li><p>先进而古怪的Lisp特性是与生俱来的，和其他语言在发展中才逐渐加入新的特性相比，Lisp诞生之初就具有理论和数学上的完备。</p>
</li>
<li><p>Lisp在互联网应用程序的服务器上的表现更能体现它的优越之处，这就是在苛刻条件下利用高级工具的结果。</p>
</li>
<li><p>Lisp可能会带来很多问题，当Lisp可以跑在你能够控制的服务器上时协同就不是问题；当函数库不如构建规模庞大的系统重要时就不必去理会现成的函数库；小而美的团队可以解决很大的问题，因此并不需要找到很多精通Lisp的黑客。</p>
</li>
<li><p>随大流的公司们最终会因为选择了大流的工具而陷入困境，选择了更想的工具的他们的竞争对手会用更小的代价获得更好的效果并最终打败他们。</p>
</li>
<li><p>远离所谓的“业界最佳实践”实际上是让你远离平庸技术的诀窍，因为顶尖的技术往往就是最小众的。</p>
</li>
</ul>
<h3 id="第十四章-梦寐以求的编程语言"><a href="#第十四章-梦寐以求的编程语言" class="headerlink" title="第十四章 梦寐以求的编程语言"></a>第十四章 梦寐以求的编程语言</h3><p>这一章作者向我们描述了成就一门优秀的编程语言的特性，结合这些特性作者向我们展示了可能会是梦寐以求的编程语言的存在条件。</p>
<ul>
<li><p>成就编程语言流行程度的秘诀包括专业黑客们的看法、达到“临界数量”的使用人数，把握了最初的高级黑客、塑造了成功的产品，最终将推动这门编程语言的发展。</p>
</li>
<li><p>能够依附在一个优秀的平台上同时拥有一个好的实现是编程语言取得成功的外部条件。</p>
<ul>
<li>保持编程语言语法和表达上的简洁将会使得追求简洁表达的黑客们喜欢上这门语言。</li>
</ul>
</li>
<li><p>向黑客们敞开胸怀让他们能够充分理解和改造的编程语言将使其更便于应用，这个特性将使这门编程语言解决问题的能力充分体现。</p>
</li>
<li><p>具有良好互动性的“一次性”语言容易装备且同时很易于完成任务，久而久之，大规模的使用将很容易使得这种语言成为主流。</p>
</li>
<li><p>优秀的语言如果配上众多经过认真设计的函数库将给使用者带来实际使用上的巨大便利。</p>
</li>
<li><p>好的性能分析器将会使得使用者非常容易注意到代码运行的瓶颈处，甚至和编译器的作用不相上下，同时使用者创造出的代码和应用最终将会获得很高的效率。</p>
</li>
<li><p>经受时间考验的编程语言往往是默默自然成长起来的，新事物获得认可所需的一个长时间段同样适用于编程语言。</p>
</li>
<li><p>能够让使用者再设计是好的编程语言变得更好的一个绝佳方法，语言的推动者们如果能够在小而精的范围内提出再设计的反馈将使得语言良性地发展。</p>
</li>
</ul>
<h3 id="第十五章-设计与研究"><a href="#第十五章-设计与研究" class="headerlink" title="第十五章 设计与研究"></a>第十五章 设计与研究</h3><p>这一章作者为我们阐释了软件设计的细节，某些软件工程中真正起作用的东西就是软件设计的技巧。</p>
<ul>
<li><p>设计和研究相比，前者求好，后者求新，作者向我们提出了设计好的编程语言而非研究新的编程语言更为重要。</p>
</li>
<li><p>软件设计的起点应该是抓对使用最终产品的人，找准他们需要的而非要求的需求。</p>
</li>
<li><p>编程语言的设计要注重的不仅是程序的表达方式，更应该把它看成是能够促进使用者思考过程的媒介，因此恰到好处的设计尤为重要。这里作者再度提到了动态语言的优点，加入了“交互式顶层解释器”的帮助，变量的类型声明得以解放出来，为使用者的思考过程带来更多便利。</p>
</li>
<li><p>贴近用户就是尽快给用户一个产品的模型，一个整体的模型建立出来后再添砖加瓦、逐代更替，最终会使一个完整的形象始终呈现在设计者面前，这样不仅能够获得用户评估的支持，同时也会使得设计者因逐步变化带来的进步而获得鼓励。</p>
</li>
</ul>
<blockquote>
<p>本文属于博主在拉勾网二进制club读书会活动中对这本名作的再读感悟。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="羅金浩" />
          <p class="site-author-name" itemprop="name">羅金浩</p>
          <p class="site-description motion-element" itemprop="description">金浩的［賅］博客</br>写点我想明白的</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">30</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/JinhaoPlus" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/JinhaoTek/" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://segmentfault.com/u/jinhaoplus" target="_blank" title="SegmentFault">
                  
                    <i class="fa fa-fw fa-laptop"></i>
                  
                  SegmentFault
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:rocking2013@hotmail.com" target="_blank" title="Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                  Mail
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">羅金浩</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"jinhaoplus"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
